<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Diary</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        /* CSS Variables for Light and Dark Themes */
        :root {
            --bg-color: #ffffff;
            --text-color: #252525;
            --secondary-bg: rgba(235, 232, 232, 0.95);
            --hint-color: rgba(0, 0, 0, 0.3);
            --button-color: #3498dbb4;
            --button-text-color: #dddddd;
            --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.8);
            --positive-color: #2ecc71;
            --negative-color: #e74c3c;
            --refund-color: #3498db;
            --profit-bg: #e8f5e9;
            --loss-bg: #ffebee;
            --refund-bg: #e3f2fd;
            --cell-bg: #fafafa;
            --cell-hover-bg: #e3f2fd;
            --modal-bg: #ffffff;
            --input-bg: #ffffff;
            --input-border: #ddd;
            --progress-bg: #e0e0e0;
            --progress-profit: #4CAF50;
            --progress-loss: #F44336;
            --tab-bg: #ecf0f1;
            --tab-active-bg: #3498dbb4;
            --notification-success: #27ae60;
            --notification-error: #e74c3c;
        }

        [data-theme="dark"] {
            --bg-color: #242424;
            --text-color: #dddddd;
            --secondary-bg: #2d2d2d;
            --hint-color: rgba(255, 255, 255, 0.3);
            --button-color: #3498dbb4;
            --button-text-color: #dddddd;
            --border-color: #444444;
            --shadow-color: rgba(0, 0, 0, 0.8);
            --positive-color: #4CAF50;
            --negative-color: #F44336;
            --refund-color: #2196F3;
            --profit-bg: #1b2e1b;
            --loss-bg: #2e1b1b;
            --refund-bg: #1b1e2e;
            --cell-bg: #2d2d2d;
            --cell-hover-bg: #3d3d3d;
            --modal-bg: #2d2d2d;
            --input-bg: #3d3d3d;
            --input-border: #555555;
            --progress-bg: #444444;
            --progress-profit: #4CAF50;
            --progress-loss: #F44336;
            --tab-bg: #2d2d2d;
            --tab-active-bg: #3498dbb4;
            --notification-success: #4CAF50;
            --notification-error: #F44336;
        }

        [data-theme="dark"] .balance-label,
        [data-theme="dark"] .progress-label,
        [data-theme="dark"] .setting-label {
            color: var(--text-color);
        }

        [data-theme="dark"] .settings-panel h3 {
            color: var(--text-color);
        }

        [data-theme="dark"] .progress-stats {
            color: var(--text-color);
        }
        [data-theme="dark"] .progress-bar {
            background: var(--progress-bg);
        }

        [data-theme="dark"] .progress-container {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
        }


        [data-theme="dark"] .date-label {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        [data-theme="dark"] .month-comments textarea {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }

        [data-theme="dark"] .settings-panel {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Roboto', Arial, sans-serif;
        }
        
        body {
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 5px;
            font-size: 14px;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 2px 12px var(--shadow-color);
            overflow: hidden;
            border: 1px solid var(--hint-color);
        }
        
        header {
            background: var(--bg-color);
            color: var(--text-color);
            padding: 10px;
            text-align: left;
            position: relative;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            gap: 10px;
            min-height: 40px;
        }

        .header-content h1 {
            margin: 0;
            font-size: 1.5rem;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .date-display {
            white-space: nowrap;
            flex-shrink: 0;
            font-size: 0.9rem;
        }
        
        /* Адаптивность для мобильных устройств */
        @media (max-width: 480px) {
            .header-content {
                gap: 8px;
            }

            .header-content h1 {
                font-size: 1.3rem;
            }

            .header-actions {
                gap: 8px;
            }

            .export-header-btn {
                font-size: 0.75rem;
                padding: 5px 10px;
            }

            .date-display {
                font-size: 0.8rem;
            }
        }

        @media (max-width: 400px) {
            .header-content {
                gap: 6px;
            }

            .header-content h1 {
                font-size: 1.2rem;
            }

            .export-header-btn {
                font-size: 0.7rem;
                padding: 4px 8px;
            }

            .date-display {
                font-size: 0.75rem;
            }
        }

        @media (max-width: 360px) {
            .header-content {
                gap: 6px;
            }

            .header-content h1 {
                font-size: 1.1rem;
                flex-shrink: 1;
            }

            .header-actions {
                flex-shrink: 0;
            }

            .export-header-btn {
                font-size: 0.65rem;
                padding: 4px 6px;
            }

            .date-display {
                font-size: 0.7rem;
            }
        }

        @media (max-width: 320px) {
            .header-content {
                gap: 4px;
            }

            .header-content h1 {
                font-size: 1.0rem;
                flex-shrink: 1;
            }

            .header-actions {
                flex-shrink: 0;
            }

            .export-header-btn {
                font-size: 0.6rem;
                padding: 3px 5px;
            }

            .date-display {
                font-size: 0.65rem;
            }
        }
        
        .btn {
            background: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
            margin: 2px;
        }
        
        .btn:hover {
            opacity: 0.9;
        }
        
        .btn-success {
            background: var(--button-color);
        }
        
        .btn-danger {
            background: var(--button-color);
        }
        
        .btn-warning {
            background: var(--button-color);
        }
        
        .main-content {
            padding: 10px;
        }
        
        .balance-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            margin-bottom: 15px;
            background: var(--bg-color);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--hint-color);
            gap: 8px;
            box-shadow: inset 0 1px 3px var(--shadow-color);
        }
        
        .balance-item {
            text-align: center;
            background: var(--secondary-bg);
            border-radius: 8px;
            padding: 8px 4px;
            border: 1px solid var(--hint-color);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }

        .balance-label {
            font-size: 0.7rem;
            color: var(--shadow-color);
            line-height: 1.2;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 1.5rem;
            min-height: 1.5rem;
            margin-bottom: 0;
        }

        .balance-value {
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            line-height: 1.2;
            transition: all 0.2s;
            color: var(--text-color);
            word-break: break-all;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 2rem;
            min-height: 2rem;
        }
        
        .starting-balance {
            background-color: var(--button-color);
            border-radius: 8px;
            padding: 6px 8px;
            border: 2px solid var(--button-color);
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            opacity: 0.7;
        }

        .starting-balance:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.8);
        }

        .starting-balance.balance-value {
            color: #007bff !important;
            border: 2px solid #007bff;
            background: rgba(0, 123, 255, 0.15);
            opacity: 0.7;
            border-radius: 6px;
            padding: 4px 8px !important;
            font-size: 0.85rem !important;
            min-height: 30px !important;
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex !important;
            align-items: center !important;
            justify-content: space-between  !important;
            gap: 8px;
            width: 100%;
        }

        .balance-amount {
            flex: 1;
            text-align: left;
            padding: 2px 0;
            font-size: 1.0rem !important;
            font-weight: 400;
            color: var(--text-color) !important;
            white-space: nowrap;
            overflow: visible;
            text-overflow: ellipsis;
        }

        .percentage-indicator {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: center;
            gap: 4px; /* Расстояние между стрелкой и процентом */
            font-size: 1.2rem !important;
            font-weight: 700;
            min-width: 2px !important;
            max-width: 80px;
            flex-shrink: 0;
            height: 100%;
        }

        .indicator-arrow {
            width: 28px !important;
            height: 18px !important;
            font-size: 16px !important;
            font-weight: 900 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none !important;
            border-radius: 0 !important;
            margin: 0;
            line-height: 1;
        }

        .indicator-percentage {
            font-size: 0.9rem !important;
            font-weight: 700;
            line-height: 1;
            margin: 0;
        }

        /* Цвета для положительной стрелки */
        .indicator-arrow.positive {
            color: #00d909 !important;
        }

        /* Цвета для отрицательной стрелки */
        .indicator-arrow.negative {
            color: var(--negative-color) !important;
        }

        /* Цвета для нейтральной стрелки */
        .indicator-arrow.neutral {
            color: var(--text-color) !important;
        }

        /* Цвета для положительного процента */
        .indicator-percentage.positive {
            color: #00d909 !important;
        }

        /* Цвета для отрицательного процента */
        .indicator-percentage.negative {
            color: var(--negative-color) !important;
        }

        /* Цвета для нейтрального процента */
        .indicator-percentage.neutral {
            color: var(--text-color) !important;
        }

        /* Адаптивные стили для мобильных устройств */
        @media (max-width: 400px) {
            .starting-balance.balance-value {
                padding: 3px 6px !important;
                font-size: 0.8rem !important;
                min-height: 28px !important;
                gap: 1px;
            }

            .balance-amount {
                font-size: 0.9rem !important;
            }

            .percentage-indicator {
                font-size: 1.0rem !important;
                min-width: 1px !important;
                gap: 6px;
            }

            .indicator-arrow {
                width: 24px !important;
                height: 16px !important;
                font-size: 14px !important;
            }

            .indicator-percentage {
                font-size: 0.6rem !important;
            }
        }

        @media (max-width: 360px) {
            .starting-balance.balance-value {
                padding: 2px 4px !important;
                font-size: 0.75rem !important;
                min-height: 26px !important;
                gap: 4px;
            }

            .balance-amount {
                font-size: 0.85rem !important;
            }

            .percentage-indicator {
                font-size: 0.9rem !important;
                min-width: 1px !important;
                gap: 3px;
            }

            .indicator-arrow {
                width: 20px !important;
                height: 14px !important;
                font-size: 12px !important;
            }

            .indicator-percentage {
                font-size: 0.6rem !important;
            }
        }

        @media (max-width: 320px) {
            .starting-balance.balance-value {
                padding: 2px 3px !important;
                font-size: 0.7rem !important;
                min-height: 24px !important;
            }

            .balance-amount {
                font-size: 0.8rem !important;
            }

            .percentage-indicator {
                font-size: 0.8rem !important;
                min-width: 1px !important;
                gap: 6px;
            }

            .indicator-arrow {
                width: 18px !important;
                height: 12px !important;
                font-size: 11px !important;
            }

            .indicator-percentage {
                font-size: 0.6rem !important;
            }
        }

        .positive {
            color: var(--positive-color);
        }

        .negative {
            color: var(--negative-color);
        }

        /* Обновляем стили для индикатора баланса - мобильная адаптация */
        @media (max-width: 400px) {
            #percentage-indicator {
                font-size: 0.4rem !important;
                min-width: 25px !important;
            }

            #indicator-arrow {
                width: 12px !important;
                height: 15px !important;
                font-size: 16px !important;
            }

            #indicator-percentage {
                font-size: 0.7rem !important;
            }
        }

        @media (max-width: 360px) {
            #percentage-indicator {
                font-size: 0.35rem !important;
                min-width: 22px !important;
            }

            #indicator-arrow {
                width: 12px !important;
                height: 15px !important;
                font-size: 16px !important;
            }

            #indicator-percentage {
                font-size: 0.7rem !important;
            }
        }

        @media (max-width: 320px) {
            #percentage-indicator {
                font-size: 0.3rem !important;
                min-width: 20px !important;
            }

            #indicator-arrow {
                width: 12px !important;
                height: 12px !important;
                font-size: 15px !important;
            }

            #indicator-percentage {
                font-size: 0.5rem !important;
            }
        }
        
        .table-container {
            overflow-x: auto;
            margin-bottom: 10px;
            border: 1px solid var(--hint-color);
            border-radius: 10px;
            width: 100%;
            box-shadow: 0 1px 3px var(--shadow-color);
        }
        
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: var(--bg-color);
            font-size: 0.8rem;
            table-layout: fixed;
            color: var(--text-color);
            border-radius: 10px;
            overflow: hidden;
        }
        
        th, td {
            border-bottom: 1px solid var(--hint-color);
            border-right: 1px solid var(--hint-color);
            padding: 8px;
            text-align: center;
            min-width: 60px;
            height: 40px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-color);
        }
        
        th {
            background: var(--button-color);
            color: var(--button-text-color);
            position: sticky;
            top: 0;
            font-weight: 600;
            white-space: normal;
            word-break: keep-all;
            line-height: 1.3;
            padding: 12px 10px;
            text-align: center;
            font-size: 0.8rem;
            min-width: 120px;
            overflow: visible;
            text-overflow: clip;
        }

        
        th:last-child, td:last-child {
            border-right: none;
        }
        
        tr:last-child td {
            border-bottom: none;
        }
        
        .trade-header {
            background: var(--bg-color);
            color: var(--text-color);
            width: 50px;
        }
        
        .cell {
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            background-color: var(--cell-bg);
        }

        .cell:hover {
            background-color: var(--cell-hover-bg);
        }
        
        .cell.disabled {
            opacity: 0.6;
            cursor: not-allowed !important;
            pointer-events: none;
        }
        
        .cell-content {
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .profit {
            background: var(--profit-bg) !important;
            color: var(--positive-color) !important;
        }

        .loss {
            background: var(--loss-bg) !important;
            color: var(--negative-color) !important;
        }

        .refund {
            background: var(--refund-bg) !important;
            color: var(--refund-color) !important;
        }
        
        .emotion-cell {
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        .comments-cell {
            text-align: left;
            max-width: 140px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .comments-cell {
            color: var(--text-color);
        }
        
        .add-trade-btn {
            margin-top: 12px;
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .add-trade-btn:hover {
            background: #27ae60; /* Зеленый вместо синего */
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .add-trade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Убраны кнопки действий */
        .telegram-actions {
            display: none;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--modal-bg);
            color: var(--text-color);
            padding: 15px;
            border-radius: 8px;
            width: 90%;
            max-width: 300px;
            text-align: center;
        }

        [data-theme="dark"] .modal-content {
            background: var(--modal-bg);
            color: var(--text-color);
        }

        [data-theme="dark"] .emotion-option {
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }

        [data-theme="dark"] .emotion-option:hover {
            background: var(--input-bg);
        }

        [data-theme="dark"] .emotion-label {
            color: var(--text-color);
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .modal-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            flex: 1;
            min-width: 80px;
        }
        
        .profit-btn {
            background: var(--positive-color);
            color: var(--button-text-color);
        }
        
        .loss-btn {
            background: var(--negative-color);
            color: var(--button-text-color);
        }
        
        .refund-btn {
            background: var(--refund-color);
            color: var(--button-text-color);
        }
        
        .reset-btn {
            background: var(--hint-color);
            color: var(--button-text-color);
        }
        
        .emotion-modal-content {
            max-width: 250px;
        }
        
        .emotion-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .emotion-option {
            padding: 8px;
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            color: var(--text-color);
        }
        
        .emotion-option:hover {
            background: var(--secondary-bg);
        }
        
        .emotion-emoji {
            font-size: 1.5rem;
            margin-bottom: 3px;
            color: var(--text-color);
        }
        
        .emotion-label {
            font-size: 0.7rem;
        }
        
        .comments-modal-content {
            max-width: 300px;
        }
        
        .comments-textarea {
            width: 100%;
            min-height: 100px;
            padding: 8px;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
            font-size: 0.8rem;
            margin-top: 10px;
        }

        [data-theme="dark"] .comments-textarea {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }
        
        .comments-textarea::placeholder {
            color: var(--hint-color);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 12px;
            background: var(--tab-bg);
            border-radius: 12px;
            overflow: hidden;
            flex-wrap: wrap;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .tab {
            flex: 1;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            min-width: 70px;
            color: var(--text-color);
            background: var(--tab-bg);
            font-weight: 500;
        }

        .tab:hover {
            background: #27ae60; /* Зеленый вместо синего */
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .tab.active {
            background: var(--tab-active-bg);
            color: var(--button-text-color);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .amount-input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .amount-input::placeholder {
            color: var(--hint-color);
        }
        
        .date-navigation {
            display: flex;
            justify-content: center;
            margin: 10px 0;
            gap: 10px;
            padding: 0 10px;
        }
        
        .date-btn {
            background: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 10px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: 0 2px 4px var(--shadow-color);
        }
        
        .date-btn:hover {
            background: #27ae60; /* Зеленый вместо синего */
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .date-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .date-label {
            padding: 10px 16px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
            background: var(--secondary-bg);
            border-radius: 20px;
            border: 1px solid var(--hint-color);
        }

        
        .notification {
            position: fixed;
            top: 0px;
            left: 10px;
            padding: 8px;
            border-radius: 4px;
            color: white;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            max-width: 200px;
            word-wrap: break-word;
        }
        
        .notification.success {
            background: var(--notification-success);
            opacity: 1;
        }

        .notification.error {
            background: var(--notification-error);
            opacity: 1;
        }
        
        /* Styles for General tab */
        .general-header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .month-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .current-date {
            font-size: 0.9rem;
            color: var(--hint-color);
        }
        
        .general-table-container {
            overflow-x: auto;
            margin-bottom: 10px;
            border: 1px solid var(--hint-color);
            border-radius: 6px;
        }
        
        .general-table {
            font-size: 0.7rem;
        }
        
        .general-table th, .general-table td {
            padding: 6px;
            text-align: center;
            min-width: 80px;
            height: 30px;
        }

        .general-table th {
            white-space: normal;
            word-break: keep-all;
            overflow: visible;
            text-overflow: clip;
            font-size: 0.8rem;
        }
        
        .general-table .editable {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .general-table .editable:hover {
            background-color: var(--secondary-bg);
        }
        
        .general-table .current-day {
            background: rgba(52, 152, 219, 0.2);
            color: var(--button-text-color) !important;
            font-weight: bold;
            border: 1px solid rgba(52, 152, 219, 0.5);
        }

        [data-theme="dark"] .general-table .current-day {
            box-shadow: 0 0 3px rgba(52, 152, 219, 0.5);
        }
        
        .withdrawal-table-container {
            margin-top: 15px;
            overflow-x: auto;
            border: 1px solid var(--hint-color);
            border-radius: 6px;
        }
        
        .withdrawal-table {
            font-size: 0.7rem;
            width: 100%;
        }
        
        .withdrawal-table th, .withdrawal-table td {
            padding: 6px;
            text-align: center;
            min-width: 90px;
            height: 30px;
        }

        .withdrawal-table th {
            white-space: normal;
            word-break: keep-all;
            overflow: visible;
            text-overflow: clip;
            font-size: 0.8rem;
        }
        
        .withdrawal-table .editable {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .withdrawal-table .editable:hover {
            background-color: var(--secondary-bg);
        }
        
        .add-withdrawal-btn {
            margin-top: 10px;
            width: 100%;
        }
        
        .add-withdrawal-btn:hover {
            background: #27ae60; /* Зеленый вместо синего */
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .month-comments {
            margin-top: 15px;
        }
        
        .month-comments textarea {
            width: 100%;
            min-height: 80px;
            padding: 8px;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
            font-size: 0.8rem;
        }

        
        .month-comments textarea::placeholder {
            color: var(--hint-color);
        }
        
        .target-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .target-modal-content {
            background: var(--modal-bg);
            color: var(--text-color);
            padding: 15px;
            border-radius: 8px;
            width: 90%;
            max-width: 280px;
            text-align: center;
        }

        [data-theme="dark"] .target-modal-content {
            background: var(--modal-bg);
            color: var(--text-color);
        }
        
        .target-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .target-modal-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        .target-input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        [data-theme="dark"] .target-input {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }
        
        .target-input::placeholder {
            color: var(--hint-color);
        }
        
        .balance-input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        [data-theme="dark"] .balance-input {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }
        
        .balance-input::placeholder {
            color: var(--hint-color);
        }
        
        .withdrawal-action-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .withdrawal-action-content {
            background: var(--modal-bg);
            color: var(--text-color);
            padding: 15px;
            border-radius: 8px;
            width: 90%;
            max-width: 250px;
            text-align: center;
        }

        [data-theme="dark"] .withdrawal-action-content {
            background: var(--modal-bg);
            color: var(--text-color);
        }
        
        .withdrawal-action-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .withdrawal-action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            flex: 1;
        }
        
        .edit-btn {
            background: var(--button-color);
            color: var(--button-text-color);
        }
        
        .delete-btn {
            background: var(--negative-color);
            color: var(--button-text-color);
        }
        
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .history-table th, .history-table td {
            border: 1px solid var(--hint-color);
            padding: 10px;
            text-align: center;
            min-width: 100px;
        }

        .history-table th {
            white-space: normal;
            word-break: keep-all;
            overflow: visible;
            text-overflow: clip;
            font-size: 0.9rem;
        }
        
        .history-table th {
            background: var(--secondary-bg);
            color: var(--text-color);
        }
        
        .progress-container {
            margin-top: 15px;
            padding: 12px;
            background: var(--secondary-bg);
            border-radius: 12px;
            border: 1px solid var(--hint-color);
            box-shadow: inset 0 1px 3px var(--shadow-color);
        }


        .progress-label {
            font-size: 0.85rem;
            margin-bottom: 8px;
            color: var(--text-color);
            text-align: center;
            font-weight: 600;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--progress-bg);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 1px 3px var(--shadow-color);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--progress-profit), var(--progress-profit));
            border-radius: 6px;
            transition: width 0.5s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, var(--hint-color), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.75rem;
            color: var(--shadow-color);
            font-weight: 500;
        }
        
        .progress-loss-fill {
            background: var(--progress-loss) !important;
        }
        
        .center-marker {
            position: absolute;
            left: 50%;
            top: 0;
            height: 100%;
            width: 2px;
            background: var(--text-color);
            transform: translateX(-50%);
            z-index: 2;
        }
        
        /* Добавленные стили для кнопок настроек */
        .settings-btn {
            margin: 5px 0;
            width: 100%;
        }

        .settings-panel {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--secondary-bg);
            border-radius: 8px;
            border: 1px solid var(--hint-color);
        }


        .settings-panel h3 {
            margin-bottom: 10px;
            color: var(--text-color);
        }
        
        .setting-row {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-color);
        }
        
        .setting-label input[type="checkbox"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            .balance-container {
                flex-direction: row;
                gap: 5px;
                padding: 6px;
            }
            
            .balance-value {
                font-size: 1.1rem;
            }
        }
        
        /* Background coloring for cells based on amounts */
        .amount-positive {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(139, 195, 74, 0.1)) !important;
        }

        .amount-negative {
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(211, 47, 47, 0.1)) !important;
        }

        .amount-zero {
            background: linear-gradient(135deg, rgba(158, 158, 158, 0.1), rgba(189, 189, 189, 0.1)) !important;
        }

        @media (max-width: 360px) {
            table th, table td {
                min-width: 45px;
                padding: 3px;
                font-size: 0.65rem;
            }

            .tab {
                min-width: 60px;
                padding: 6px;
            }

            .trade-header {
                width: 40px;
            }

            .balance-item {
                min-width: 85px;
                margin: 0 1px;
            }

            .balance-label {
                font-size: 0.7rem;
            }

            .balance-value {
                   font-size: 1rem;
               }
        }
        
        /* Ensure cohesive style for Clear buttons */
        .btn-warning {
            background: #ff9800;
            color: #fff;
            border: 2px solid #ff9800;
            border-radius: 6px;
            padding: 4px 6px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px var(--shadow-color);
            cursor: pointer;
        }

        .btn-warning:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .btn-danger {
            background: #f44336;
            color: #fff;
            border: 2px solid #f44336;
            border-radius: 6px;
            padding: 4px 6px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px var(--shadow-color);
            cursor: pointer;
        }

        .btn-danger:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            margin-bottom: 15px;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 4px 6px;
            font-weight: 600;
            border-radius: 6px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: var(--text-color);
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Размещаем текст по краям */
            background: rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            padding: 4px 8px; /* Увеличен padding для размещения текста */
            cursor: pointer;
            transition: all 0.3s ease, box-shadow 0.2s ease, transform 0.1s ease; /* Добавлены transition для эффектов */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            width: 120px;
            opacity: 0.9;
            position: relative;
            overflow: visible; /* Изменено для эффекта тени */
        }

        /* Эффект при наведении */
        .toggle-switch:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        /* Эффект при нажатии */
        .toggle-switch:active {
            transform: translateY(0px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.8);
        }

        .toggle-switch.on {
            background: rgba(255, 255, 255, 0.1);
        }

        .toggle-label {
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            z-index: 2;
            transition: opacity 0.3s ease;
            padding: 0;
            user-select: none;
        }

        .toggle-label.off {
            opacity: 1;
            left: 10px;
        }

        .toggle-label.on {
            opacity: 0.5;
            right: 10px;
        }

        .toggle-switch.on .toggle-label.off {
            opacity: 0.5;
        }

        .toggle-switch.on .toggle-label.on {
            opacity: 1;
        }

        .toggle-slider {
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            width: 46%;
            height: calc(100% - 8px);
            background: white;
            border-radius: 20px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            z-index: 1;
        }

        .toggle-switch.on .toggle-slider {
            transform: translateX(100%);
        }

        .toggle-indicator {
            width: 100%;
            height: 100%;
            background: #dc3545; /* red for OFF */
            border-radius: 20px;
            transition: background 0.3s ease;
        }

        .toggle-switch.on .toggle-indicator {
            background: #28a745; /* green for ON */
        }

        .toggle-description {
            font-size: 0.9rem;
            color: white;
            text-align: left;
            flex: 1;
        }

        /* Custom styles for settings buttons */
        #clearCurrentDayBtn {
            color: #d19e1c !important;
            border: 2px solid #d19e1c !important;
            background: #e7e7a1 !important;
            opacity: 0.7;
        }

        #clearCurrentDayBtn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        #clearAllDataBtn {
            color: #B22222 !important;
            border: 2px solid #B22222 !important;
            background: #ff7777 !important;
            opacity: 0.7;
        }

        #clearAllDataBtn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        #lightThemeBtn {
            color: #f5f5f5 !important;
            border: 2px solid #ffffff !important;
            border-radius: 6px;
            background: #c4c4c4 !important;
            opacity: 0.7;
            padding: 4px 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px var(--shadow-color)
               
        }

        #lightThemeBtn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        #darkThemeBtn {
            color: #202020 !important;
            border: 2px solid #202020 !important;
            background: #5e5e5e !important;
            border-radius: 6px;
            padding: 4px 6px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px var(--shadow-color);
            cursor: pointer;
            opacity: 0.7;
        }

        #darkThemeBtn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        #startingBalanceValue {
            background-color: #0091ca5e !important; /*  blue background */
        }
        
        /* Header actions */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .export-header-btn {
            background: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            white-space: nowrap; /* Запрещаем перенос текста */
            flex-shrink: 0;
            transition: all 0.3s;
            white-space: nowrap;
            box-shadow: 0 2px 4px var(--shadow-color);
            position: relative;
            z-index: 10;
        }

        .export-header-btn:hover {
            opacity: 1;
            background: #27ae60; /* Зеленый вместо синего */
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        /* Export modal styles */
        .export-period {
            margin: 15px 0;
        }

        .period-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .period-row label {
            min-width: 50px;
            color: var(--text-color);
            font-weight: 500;
        }

        .date-input {
            flex: 1;
            padding: 8px;
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .export-tabs {
            display: flex;
            margin: 15px 0;
            background: var(--tab-bg);
            border-radius: 8px;
            overflow: hidden;
        }

        .export-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-color);
            font-size: 0.8rem;
        }

        .export-tab.active {
            background: var(--tab-active-bg);
            color: var(--button-text-color);
        }

        /* Mobile responsiveness for header */
        @media (max-width: 480px) {
            .header-actions {
                flex-direction: column;
                gap: 5px;
                align-items: flex-end;
            }

            .export-header-btn {
                font-size: 0.7rem;
                padding: 4px 8px;
                position: relative;
                z-index: 10;
            }
        }

        @media (max-width: 360px) {
            .header-content {
                flex-wrap: wrap;
                gap: 5px;
            }

            .header-actions {
                flex-direction: row;
                width: auto;
                justify-content: flex-end;
                margin-top: 0;
                flex-shrink: 0;
            }

            .export-header-btn {
                position: relative;
                z-index: 10;
            }
        }

        @media (max-width: 320px) {
            .header-content {
                flex-wrap: wrap;
                gap: 4px;
            }

            .header-actions {
                flex-shrink: 0;
            }

            .export-header-btn {
                position: relative;
                z-index: 10;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <h1>Trading Diary</h1>
                <div class="header-actions">
                    <button class="export-header-btn" id="exportBtn" title="Export to Excel">Export</button>
                </div>
            </div>
        </header>
        
        <div class="tabs">
            <div class="tab active" data-tab="table">Table</div>
            <div class="tab" data-tab="general">General</div>
            <div class="tab" data-tab="history">History</div>
            <div class="tab" data-tab="settings">Settings</div>
        </div>
        
        <div class="main-content">
            <div class="tab-content active" id="table-tab">
                <div class="balance-container">
                    <div class="balance-item">
                        <div class="balance-label">Starting Balance</div>
                        <div class="balance-value starting-balance" id="startingBalanceValue">
                            <span class="balance-amount" id="balanceAmount">10000</span>
                            <div class="percentage-indicator" id="percentageIndicator">
                                <div class="indicator-arrow" id="indicatorArrow">●</div>
                                <span class="indicator-percentage" id="indicatorPercentage">0.0%</span>
                            </div>
                        </div>
                    </div>
                    <div class="balance-item">
                        <div class="balance-label">Current Balance</div>
                        <div class="balance-value" id="currentBalanceValue">10000</div>
                    </div>
                    <div class="balance-item">
                        <div class="balance-label">Day Result</div>
                        <div class="balance-value" id="dayResultValue">0</div>
                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-label">Daily Progress</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 50%"></div>
                    </div>
                    <div class="progress-stats">
                        <span id="progressStart">-2%</span>
                        <span id="progressCurrent">0%</span>
                        <span id="progressTarget">+2%</span>
                    </div>
                </div>
                
                <div class="date-navigation">
                    <button class="date-btn" id="prevDayBtn" aria-label="Previous day">←</button>
                    <div class="date-label" id="currentDayLabel">Today</div>
                    <button class="date-btn" id="nextDayBtn" disabled aria-label="Next day">→</button>
                </div>
                
                <div class="table-container">
                    <table id="tradingTable">
                        <thead>
                            <tr>
                                <th class="trade-header">Trade</th>
                                <th>Trade Amount</th>
                                <th>Profit/Loss Refund</th>
                                <th>Emotional State</th>
                                <th>Comments</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Table rows will be generated here -->
                        </tbody>
                    </table>
                </div>
                
                <button class="btn add-trade-btn" id="addTradeBtn" aria-label="Add new trade">+ Add Trade</button>
            </div>
            
            <!-- General Tab -->
            <div class="tab-content" id="general-tab">
                <div class="general-header">
                    <div class="current-date" id="currentGeneralDate"></div>
                </div>
                
                <div class="date-navigation">
                    <button class="date-btn" id="prevMonthBtn">←</button>
                    <div class="date-label" id="currentMonthLabel">Month Year</div>
                    <button class="date-btn" id="nextMonthBtn" disabled>→</button>
                </div>
                
                <div class="general-table-container">
                    <table class="general-table" id="generalTable">
                        <thead>
                            <tr>
                                <th>Day</th>
                                <th>Profit Target</th>
                                <th>Loss Target</th>
                                <th>Actual P/L</th>
                                <th>Winning Trades</th>
                                <th>Losing Trades</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Table rows will be generated here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="withdrawal-table-container">
                    <table class="withdrawal-table" id="withdrawalTable">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Withdrawal</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Withdrawal rows will be generated here -->
                        </tbody>
                    </table>
                </div>
                
                <button class="btn add-withdrawal-btn" id="addWithdrawalBtn">+ Add Withdrawal</button>
                
                <div class="month-comments">
                    <h3>Month Comments</h3>
                    <textarea id="monthCommentsInput" placeholder="Enter comments for the current month..."></textarea>
                </div>
            </div>
            
            <div class="tab-content" id="history-tab">
                <h2>Trading Days History</h2>
                <div class="table-container">
                    <table class="history-table" id="historyTable">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- History rows will be generated here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="tab-content" id="settings-tab">
                <h2>Application Settings</h2>
                
                <div class="settings-panel">
                    <h3>Data Management</h3>
                    <button class="btn btn-warning settings-btn" id="clearCurrentDayBtn">Clear Current Day</button>
                    <button class="btn btn-danger settings-btn" id="clearAllDataBtn">Delete all history</button>
                </div>
                
                <div class="settings-panel">
                    <h3>Display Settings</h3>
                    <div class="setting-row">
                        <button class="btn settings-btn" id="lightThemeBtn">Daylight</button>
                        <button class="btn settings-btn" id="darkThemeBtn">Midnight</button>
                    </div>
                    <div class="toggle-switch-container">
                        <label class="toggle-description">Daily Progress Bar</label>
                        <div class="toggle-switch" id="showProgressBarToggle">
                            <span class="toggle-label off">OFF</span>
                            <div class="toggle-slider">
                                <div class="toggle-indicator"></div>
                            </div>
                            <span class="toggle-label on">ON</span>
                        </div>
                    </div>
                </div>

                <div class="settings-panel">
                    <h3>About</h3>
                    <p>Trading Diary PRO v2.0</p>
                    <p>Developed for convenient tracking of trading results</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal for trade result -->
    <div class="modal" id="resultModal" role="dialog" aria-labelledby="resultModalTitle" aria-hidden="true">
        <div class="modal-content">
            <h2 class="modal-title" id="resultModalTitle">Select Trade Result</h2>
            <input type="text" class="amount-input" id="amountInput" placeholder="Enter amount" pattern="^[0-9]+([,.][0-9]+)*$" inputmode="decimal">
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" data-value="profit">Profit</button>
                <button class="modal-btn loss-btn" data-value="loss">Loss</button>
                <button class="modal-btn refund-btn" data-value="refund">Refund</button>
                <button class="modal-btn reset-btn" data-value="reset">Reset</button>
            </div>
        </div>
    </div>

    <!-- Modal for trade amount -->
    <div class="modal" id="tradeAmountModal">
        <div class="modal-content">
            <h2 class="modal-title">Enter Trade Amount</h2>
            <input type="text" class="amount-input" id="tradeAmountInput" placeholder="Enter amount" pattern="^[0-9]+([,.][0-9]+)*$" inputmode="decimal">
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveTradeAmountBtn">Save</button>
                <button class="modal-btn reset-btn" id="cancelTradeAmountBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for withdrawal -->
    <div class="modal" id="withdrawalModal">
        <div class="modal-content">
            <h2 class="modal-title">Enter Withdrawal Amount</h2>
            <input type="number" class="amount-input" id="withdrawalAmountInput" placeholder="Enter amount" step="0.01">
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveWithdrawalBtn">Save</button>
                <button class="modal-btn reset-btn" id="cancelWithdrawalBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for withdrawal actions -->
    <div class="withdrawal-action-modal" id="withdrawalActionModal">
        <div class="withdrawal-action-content">
            <h2 class="modal-title">Withdrawal Action</h2>
            <div class="withdrawal-action-buttons">
                <button class="withdrawal-action-btn edit-btn" id="editWithdrawalBtn">Edit</button>
                <button class="withdrawal-action-btn delete-btn" id="deleteWithdrawalBtn">Delete</button>
                <button class="withdrawal-action-btn reset-btn" id="cancelWithdrawalActionBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for emotions -->
    <div class="modal" id="emotionModal">
        <div class="modal-content emotion-modal-content">
            <h2 class="modal-title">Select Emotional State</h2>
            <div class="emotion-options">
                <div class="emotion-option" data-emotion="fear">
                    <div class="emotion-emoji">😨</div>
                    <div class="emotion-label">Fear</div>
                </div>
                <div class="emotion-option" data-emotion="greed">
                    <div class="emotion-emoji">🤑</div>
                    <div class="emotion-label">Greed</div>
                </div>
                <div class="emotion-option" data-emotion="joy">
                    <div class="emotion-emoji">😁</div>
                    <div class="emotion-label">Joy</div>
                </div>
                <div class="emotion-option" data-emotion="uncertainty">
                    <div class="emotion-emoji">😕</div>
                    <div class="emotion-label">Uncertainty</div>
                </div>
                <div class="emotion-option" data-emotion="neutral">
                    <div class="emotion-emoji">😐</div>
                    <div class="emotion-label">Neutral</div>
                </div>
                <div class="emotion-option" data-emotion="frustration">
                    <div class="emotion-emoji">😤</div>
                    <div class="emotion-label">Frustration</div>
                </div>
                <div class="emotion-option" data-emotion="contemplation">
                    <div class="emotion-emoji">🤔</div>
                    <div class="emotion-label">Contemplation</div>
                </div>
                <div class="emotion-option" data-emotion="boredom">
                    <div class="emotion-emoji">😴</div>
                    <div class="emotion-label">Boredom</div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn reset-btn" id="clearEmotionBtn">Clear</button>
            </div>
        </div>
    </div>

    <!-- Modal for comments -->
    <div class="modal" id="commentsModal">
        <div class="modal-content comments-modal-content">
            <h2 class="modal-title">Add Comment</h2>
            <textarea class="comments-textarea" id="commentsInput" placeholder="Enter comment..."></textarea>
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveCommentBtn">Save</button>
                <button class="modal-btn reset-btn" id="cancelCommentBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for setting balance -->
    <div class="modal" id="balanceModal">
        <div class="modal-content">
            <h2 class="modal-title">Set Starting Balance</h2>
            <input type="number" class="balance-input" id="balanceInput" placeholder="Enter balance" step="0.01">
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveBalanceBtn">Save</button>
                <button class="modal-btn reset-btn" id="cancelBalanceBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for setting targets -->
    <div class="target-modal" id="targetModal">
        <div class="target-modal-content">
            <h2 class="modal-title" id="targetModalTitle">Set Target (%)</h2>
            <input type="text" class="target-input" id="targetInput" placeholder="Enter value in %" pattern="^[0-9.,-]+$" inputmode="decimal">
            <div class="target-modal-buttons">
                <button class="target-modal-btn" id="applyToDayBtn">Day Only</button>
                <button class="target-modal-btn" id="applyToAllBtn">All Days</button>
                <button class="target-modal-btn" id="cancelTargetBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for export -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <h2 class="modal-title">Export to Excel</h2>
            <div class="export-period">
                <div class="period-row">
                    <label>From:</label>
                    <input type="date" id="exportStartDate" class="date-input">
                </div>
                <div class="period-row">
                    <label>To:</label>
                    <input type="date" id="exportEndDate" class="date-input">
                </div>
            </div>
            <div class="export-tabs">
                <div class="export-tab active" data-tab="table">Table Data</div>
                <div class="export-tab" data-tab="general">General Data</div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveExportBtn">Export</button>
                <button class="modal-btn reset-btn" id="cancelExportBtn">Cancel</button>
                <button class="modal-btn profit-btn" id="browserExportBtn" style="background: #ff9800;">Open in Browser</button>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>
    
    <script>
        function s2ab(s) {
            const buf = new ArrayBuffer(s.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 0xFF;
            return buf;
        }

        function exportExcel(data, filename = 'export.xlsx') {
            // Создаем книгу и лист с данными
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.json_to_sheet(data);
            XLSX.utils.book_append_sheet(wb, ws, 'Export');

            // Записываем книгу в бинарный формат
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'binary' });

            // Создаем Blob из бинарных данных
            const blob = new Blob([s2ab(wbout)], { type: 'application/octet-stream' });

            // Создаем ссылку на скачивание
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            // Удаляем ссылку и освобождаем память
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        }

        console.log('Trading Diary script loaded');
        // Initialize Telegram Web App
        let tg = window.Telegram?.WebApp;
        console.log('Telegram WebApp object:', tg);
        
        document.addEventListener('DOMContentLoaded', function() {
            // Theme management
            function updateTheme() {
                const savedTheme = localStorage.getItem('theme') || 'dark'; // Default to dark
                console.log('updateTheme called, savedTheme:', savedTheme);
                if (savedTheme === 'dark') {
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.removeAttribute('data-theme');
                }
                console.log('Applied theme: ' + savedTheme);
                console.log('data-theme attribute after updateTheme:', document.documentElement.getAttribute('data-theme'));
                setTimeout(logStartingBalanceStyles, 500);
                setTimeout(logCommentStyles, 500);
            }

            function switchTheme(theme) {
                console.log('switchTheme called with theme:', theme);
                if (theme === 'dark') {
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.removeAttribute('data-theme');
                }
                localStorage.setItem('theme', theme);
                console.log('Switched to ' + theme + ' theme');
                console.log('data-theme attribute set to:', document.documentElement.getAttribute('data-theme'));
                updateTheme();
                updateProgressBar(); // Обновляем прогресс-бар при переключении темы
                console.log('Progress bar updated after theme switch');
                // Обновляем стили для открытых модалей
                const openModals = document.querySelectorAll('.modal[style*="display: flex"], .target-modal[style*="display: flex"], .withdrawal-action-modal[style*="display: flex"]');
                openModals.forEach(modal => {
                    modal.style.background = getComputedStyle(document.documentElement).getPropertyValue('--modal-bg');
                    modal.style.color = getComputedStyle(document.documentElement).getPropertyValue('--text-color');
                });
            }

            // Initial theme setup
            updateTheme();

            // Expand the app to full screen
            if (tg && tg.expand) {
                tg.expand();
            }
            
            // Elements
            const tradingTable = document.getElementById('tradingTable');
            const resultModal = document.getElementById('resultModal');
            const tradeAmountModal = document.getElementById('tradeAmountModal');
            const withdrawalModal = document.getElementById('withdrawalModal');
            const withdrawalActionModal = document.getElementById('withdrawalActionModal');
            const emotionModal = document.getElementById('emotionModal');
            const commentsModal = document.getElementById('commentsModal');
            const balanceModal = document.getElementById('balanceModal');
            const historyTable = document.getElementById('historyTable');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const notification = document.getElementById('notification');
            const amountInput = document.getElementById('amountInput');
            const tradeAmountInput = document.getElementById('tradeAmountInput');
            const withdrawalAmountInput = document.getElementById('withdrawalAmountInput');
            const balanceInput = document.getElementById('balanceInput');
            const prevDayBtn = document.getElementById('prevDayBtn');
            const currentDayLabel = document.getElementById('currentDayLabel');
            const nextDayBtn = document.getElementById('nextDayBtn');
            const addTradeBtn = document.getElementById('addTradeBtn');
            const addWithdrawalBtn = document.getElementById('addWithdrawalBtn');
            const monthCommentsInput = document.getElementById('monthCommentsInput');
            
            // Progress elements
            const progressFill = document.getElementById('progressFill');
            const progressStart = document.getElementById('progressStart');
            const progressCurrent = document.getElementById('progressCurrent');
            const progressTarget = document.getElementById('progressTarget');
            
            // Balance elements
            const startingBalanceValue = document.getElementById('startingBalanceValue');
            const currentBalanceValue = document.getElementById('currentBalanceValue');
            const dayResultValue = document.getElementById('dayResultValue');
            const saveBalanceBtn = document.getElementById('saveBalanceBtn');
            const cancelBalanceBtn = document.getElementById('cancelBalanceBtn');
            
            // Clear buttons
            const clearCurrentDayBtn = document.getElementById('clearCurrentDayBtn');
            const clearAllDataBtn = document.getElementById('clearAllDataBtn');
            
            // Elements for General tab
            const currentGeneralDate = document.getElementById('currentGeneralDate');
            const generalTable = document.getElementById('generalTable');
            const saveWithdrawalBtn = document.getElementById('saveWithdrawalBtn');
            const cancelWithdrawalBtn = document.getElementById('cancelWithdrawalBtn');
            const withdrawalTable = document.getElementById('withdrawalTable');
            const targetModal = document.getElementById('targetModal');
            const targetModalTitle = document.getElementById('targetModalTitle');
            const targetInput = document.getElementById('targetInput');
            const applyToDayBtn = document.getElementById('applyToDayBtn');
            const applyToAllBtn = document.getElementById('applyToAllBtn');
            const cancelTargetBtn = document.getElementById('cancelTargetBtn');

            // Elements for emotion and comment modals
            const clearEmotionBtn = document.getElementById('clearEmotionBtn');
            const commentsInput = document.getElementById('commentsInput');
            const saveCommentBtn = document.getElementById('saveCommentBtn');
            const cancelCommentBtn = document.getElementById('cancelCommentBtn');

            // Elements for percentage indicator
            const percentageIndicator = document.getElementById('percentageIndicator');
            const indicatorArrow = document.getElementById('indicatorArrow');
            const indicatorPercentage = document.getElementById('indicatorPercentage');
            const balanceAmount = document.querySelector('.balance-amount');

            console.log('Percentage indicator elements initialized:');
            console.log('percentageIndicator:', percentageIndicator);
            console.log('indicatorArrow:', indicatorArrow);
            console.log('indicatorPercentage:', indicatorPercentage);
            console.log('balanceAmount:', balanceAmount);

            // Elements for trade amount modal
            const saveTradeAmountBtn = document.getElementById('saveTradeAmountBtn');
            const cancelTradeAmountBtn = document.getElementById('cancelTradeAmountBtn');

            // Elements for withdrawal action modal
            const editWithdrawalBtn = document.getElementById('editWithdrawalBtn');
            const deleteWithdrawalBtn = document.getElementById('deleteWithdrawalBtn');
            const cancelWithdrawalActionBtn = document.getElementById('cancelWithdrawalActionBtn');

            // New elements for General tab navigation
            const prevMonthBtn = document.getElementById('prevMonthBtn');
            const currentMonthLabel = document.getElementById('currentMonthLabel');
            const nextMonthBtn = document.getElementById('nextMonthBtn');

            // State
            let currentDate = new Date();
            let trades = [];
            let currentCell = null;
            let currentTradeIndex = null;
            let currentColumnType = null;
            let tradeData = {};
            let historyData = JSON.parse(localStorage.getItem('tradeHistory')) || {};
            let generalData = JSON.parse(localStorage.getItem('generalData')) || {};
            let withdrawalData = JSON.parse(localStorage.getItem('withdrawalData')) || {};
            let monthCommentsData = JSON.parse(localStorage.getItem('monthCommentsData')) || {};
            let appSettings = JSON.parse(localStorage.getItem('appSettings')) || {
                initialBalance: 10000,
                startingBalance: 10000,
                currentBalance: 10000
            };
            
            // Emotion mapping
            const emotionMap = {
                'fear': '😨 Fear',
                'greed': '🤑 Greed',
                'joy': '😁 Joy',
                'uncertainty': '😕 Uncertainty',
                'neutral': '😐 Neutral',
                'frustration': '😤 Frustration',
                'contemplation': '🤔 Contemplation',
                'boredom': '😴 Boredom'
            };
            
            // UI Settings
            let uiSettings = JSON.parse(localStorage.getItem('uiSettings')) || {
                showProgressBar: true
            };

            // Variables for target management
            let currentTargetDay = null;
            let currentTargetType = null;

            // Variables for withdrawal management
            let currentWithdrawalDate = null;
            let currentWithdrawalIndex = null;
            let isEditingWithdrawal = false;

            // Variables for General tab month navigation
            let currentGeneralYear, currentGeneralMonth;
            
            // Initialize
            function init() {
                console.log('Initializing trading diary app');

                // Load balance settings
                if (appSettings.startingBalance && balanceAmount) {
                    balanceAmount.textContent = formatNumber(appSettings.startingBalance);
                }
                
                console.log('Starting Balance element:', startingBalanceValue);
                console.log('Balance modal:', balanceModal);
                
                // Add global click listener for debugging
                document.addEventListener('click', (e) => {
                    console.log('Click on:', e.target);
                    console.log('Class:', e.target.className);
                });
                
                // Пересчитываем текущий баланс с учетом всех сделок и выводов
                recalculateCurrentBalance();
                
                const dateKey = formatDateKey(currentDate);
                if (historyData[dateKey]) {
                    // Исправление: глубокое копирование данных для дня
                    tradeData = JSON.parse(JSON.stringify(historyData[dateKey]));
                    trades = tradeData.trades || [];
                    renderTable();
                    updateDayResultForCurrentDate();
                } else {
                    initTrades();
                    renderTable();
                }
                
                // Initialize General tab
                initGeneralTab();
                
                renderHistory();
                
                // Initialize withdrawal table
                renderWithdrawalTable();
                
                // Load month comments
                loadMonthComments();
                
                // Update navigation buttons
                updateNavigationButtons();
                
                // Update current day label
                updateCurrentDayLabel();
                
                // Проверяем, можно ли редактировать текущую дату
                updateEditPermissions();
                
                // Initialize progress bar
                updateProgressBar();

                // Initialize progress bar visibility
                updateProgressBarVisibility();

                // Initialize percentage indicator
                console.log('About to call updatePercentageIndicator() during init');
                updatePercentageIndicator();
                console.log('updatePercentageIndicator() called during init');
                console.log('App initialized successfully');

                // Log Starting Balance styles after init
                setTimeout(logStartingBalanceStyles, 1000);
            }
            
            // Функция для добавления новой сделки без полной перерисовки
            function addTradeToTable() {
                const newTrade = {
                    tradeAmount: null,
                    result: null,
                    emotion: null,
                    comment: ''
                };

                trades.push(newTrade);

                const tbody = tradingTable.querySelector('tbody');
                const row = createTableRow(trades.length - 1, newTrade);
                tbody.appendChild(row);

                // Обновляем права доступа для ячеек
                updateEditPermissions();
                refreshAllDisplays();
                updatePercentageIndicator();
            }
            
            function saveTradeData() {
                // Сохраняем данные только если есть хотя бы одна заполненная сделка
                if (!hasDayData(trades)) {
                    const dateKey = formatDateKey(currentDate);
                    // Удаляем пустые данные из истории
                    delete historyData[dateKey];
                } else {
                    tradeData.trades = trades;
                    const dateKey = formatDateKey(currentDate);
                    historyData[dateKey] = JSON.parse(JSON.stringify(tradeData)); // Глубокое копирование
                }
                
                localStorage.setItem('tradeHistory', JSON.stringify(historyData));
            }
            
            function saveSettings() {
                localStorage.setItem('appSettings', JSON.stringify(appSettings));
            }
            
            function saveUISettings() {
                localStorage.setItem('uiSettings', JSON.stringify(uiSettings));
            }

            // Функция для проверки, есть ли в дне какие-либо данные
            function hasDayData(dayTrades) {
                if (!dayTrades || dayTrades.length === 0) return false;
                
                for (let i = 0; i < dayTrades.length; i++) {
                    const trade = dayTrades[i];
                    if (trade.tradeAmount !== null || trade.result !== null || 
                        trade.emotion !== null || (trade.comment && trade.comment !== '')) {
                        return true;
                    }
                }
                return false;
            }

            // Функция для пересчета текущего баланса с учетом всех сделок и выводов
            function recalculateCurrentBalance() {
                let totalProfitLoss = 0;
                let totalWithdrawals = 0;
                
                // Суммируем все прибыли/убытки из истории
                Object.keys(historyData).forEach(dateKey => {
                    const dayData = historyData[dateKey];
                    if (dayData.trades) {
                        dayData.trades.forEach(trade => {
                            if (trade.result) {
                                if (trade.result.type === 'profit') {
                                    totalProfitLoss += trade.result.amount;
                                } else if (trade.result.type === 'loss') {
                                    totalProfitLoss -= trade.result.amount;
                                }
                            }
                        });
                    }
                });
                
                // Суммируем все выводы
                Object.keys(withdrawalData).forEach(dateKey => {
                    withdrawalData[dateKey].forEach(withdrawal => {
                        totalWithdrawals += withdrawal.amount;
                    });
                });
                
                // Обновляем текущий баланс
                appSettings.currentBalance = appSettings.startingBalance + totalProfitLoss - totalWithdrawals;
                
                // ВСЕГДА обновляем отображение
                if (currentBalanceValue) {
                    currentBalanceValue.textContent = formatNumber(appSettings.currentBalance);
                }
                
                saveSettings();
                
                return appSettings.currentBalance;
            }

            // Функция для обновления результата дня для текущей даты
            function updateDayResultForCurrentDate() {
                if (!dayResultValue) return;

                let dayTotal = 0;
                // Используем текущие данные trades вместо historyData для мгновенного обновления
                for (let i = 0; i < trades.length; i++) {
                    const trade = trades[i];
                    if (trade.result !== null) {
                        const amount = trade.result.amount;
                        const type = trade.result.type;

                        if (type === 'profit') {
                            dayTotal += amount;
                        } else if (type === 'loss') {
                            dayTotal -= amount;
                        }
                    }
                }

                dayResultValue.textContent = formatNumber(dayTotal);
                if (dayTotal > 0) {
                    dayResultValue.classList.add('positive');
                    dayResultValue.classList.remove('negative');
                } else if (dayTotal < 0) {
                    dayResultValue.classList.add('negative');
                    dayResultValue.classList.remove('positive');
                } else {
                    dayResultValue.classList.remove('positive', 'negative');
                }

                // Обновляем процентный индикатор при изменении результата дня
                updatePercentageIndicator();

                // Сохраняем данные
                saveTradeData();
            }
            
            // Функция для обновления отображения результата дня
            function updateDayResultDisplay() {
                if (!dayResultValue) return;
                
                const dateKey = formatDateKey(currentDate);
                const dayData = historyData[dateKey];
                
                if (dayData && dayData.trades) {
                    let dayTotal = 0;
                    for (let i = 0; i < dayData.trades.length; i++) {
                        const trade = dayData.trades[i];
                        if (trade.result !== null) {
                            const amount = trade.result.amount;
                            const type = trade.result.type;
                            
                            if (type === 'profit') {
                                dayTotal += amount;
                            } else if (type === 'loss') {
                                dayTotal -= amount;
                            }
                        }
                    }
                    
                    dayResultValue.textContent = formatNumber(dayTotal);
                    if (dayTotal > 0) {
                        dayResultValue.classList.add('positive');
                        dayResultValue.classList.remove('negative');
                    } else if (dayTotal < 0) {
                        dayResultValue.classList.add('negative');
                        dayResultValue.classList.remove('positive');
                    } else {
                        dayResultValue.classList.remove('positive', 'negative');
                    }
                } else {
                    dayResultValue.textContent = '0';
                    dayResultValue.classList.remove('positive', 'negative');
                }
            }

            // Получить сегодняшнюю дату в локальном часовом поясе
            function getToday() {
                const now = new Date();
                return new Date(now.getFullYear(), now.getMonth(), now.getDate());
            }

            // Форматирование даты в локальном часовом поясе
            function formatDate(date) {
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}.${month}.${year}`;
            }
            
            // Форматирование ключа даты в локальном часовом поясе
            function formatDateKey(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }
            
            // Парсинг ключа даты в локальном часовом поясе
            function parseDateKey(dateKey) {
                const [year, month, day] = dateKey.split('-').map(Number);
                return new Date(year, month - 1, day);
            }
            
            function formatNumber(amount) {
                // Проверяем, является ли число целым
                if (Number.isInteger(amount)) {
                    return new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(amount);
                } else {
                    // Для дробных чисел сохраняем значимые цифры
                    return new Intl.NumberFormat('en-US', { maximumFractionDigits: 10 }).format(amount);
                }
            }
            
            function initTrades() {
                trades = [];
                for (let i = 0; i < 5; i++) {
                    trades.push({
                        tradeAmount: null,
                        result: null,
                        emotion: null,
                        comment: ''
                    });
                }
                tradeData.trades = trades;
            }
            
            function renderTable() {
                if (!tradingTable) return;
                
                const tbody = tradingTable.querySelector('tbody');
                
                if (!tbody) return;
                
                // Очищаем таблицу только если это первоначальная отрисовка или количество сделок изменилось
                if (tbody.children.length !== trades.length) {
                    tbody.innerHTML = '';
                    
                    for (let i = 0; i < trades.length; i++) {
                        const row = createTableRow(i, trades[i]);
                        tbody.appendChild(row);
                    }
                } else {
                    // Обновляем только измененные ячейки
                    for (let i = 0; i < trades.length; i++) {
                        updateTableRow(tbody.children[i], i, trades[i]);
                    }
                }
                
                // Обновляем права доступа для ячеек
                updateEditPermissions();
            }
            
            // Создание строки таблицы
            function createTableRow(index, trade) {
                const row = document.createElement('tr');
                
                const tradeCell = document.createElement('td');
                tradeCell.textContent = index + 1;
                tradeCell.className = 'trade-header';
                row.appendChild(tradeCell);
                
                const tradeAmountCell = document.createElement('td');
                tradeAmountCell.className = 'cell';

                if (trade.tradeAmount !== null && trade.tradeAmount !== 0) {
                    tradeAmountCell.textContent = formatNumber(trade.tradeAmount);
                    if (trade.tradeAmount > 0) {
                        tradeAmountCell.classList.add('amount-positive');
                    } else if (trade.tradeAmount < 0) {
                        tradeAmountCell.classList.add('amount-negative');
                    } else {
                        tradeAmountCell.classList.add('amount-zero');
                    }
                } else {
                    tradeAmountCell.textContent = 'Click to enter amount';
                    tradeAmountCell.style.color = 'var(--hint-color)';
                    tradeAmountCell.style.fontStyle = 'italic';
                }
                
                tradeAmountCell.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    currentCell = tradeAmountCell;
                    currentTradeIndex = index;
                    currentColumnType = 'amount';
                    if (tradeAmountInput) tradeAmountInput.value = (trade.tradeAmount && trade.tradeAmount !== 0) ? trade.tradeAmount : '';
                    if (tradeAmountModal) tradeAmountModal.style.display = 'flex';
                });
                
                row.appendChild(tradeAmountCell);
                
                const resultCell = document.createElement('td');
                resultCell.className = 'cell';

                if (trade.result !== null) {
                    const amount = trade.result.amount;
                    const type = trade.result.type;

                    if (type === 'profit') {
                        resultCell.className += ' profit';
                        if (amount > 0) {
                            resultCell.classList.add('amount-positive');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-negative');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        resultCell.innerHTML = `<div class="cell-content">+${formatNumber(amount)}</div>`;
                    } else if (type === 'loss') {
                        resultCell.className += ' loss';
                        if (amount > 0) {
                            resultCell.classList.add('amount-negative');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-positive');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        resultCell.innerHTML = `<div class="cell-content">-${formatNumber(amount)}</div>`;
                    } else if (type === 'refund') {
                        resultCell.className += ' refund';
                        if (amount > 0) {
                            resultCell.classList.add('amount-positive');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-negative');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        if (amount > 0) {
                            resultCell.innerHTML = `<div class="cell-content">Refund: ${formatNumber(amount)}</div>`;
                        } else {
                            resultCell.innerHTML = `<div class="cell-content">Refund</div>`;
                        }
                    }
                }
                
                resultCell.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    currentCell = resultCell;
                    currentTradeIndex = index;
                    currentColumnType = 'result';
                    if (amountInput) amountInput.value = '';
                    if (resultModal) resultModal.style.display = 'flex';
                });
                
                row.appendChild(resultCell);
                
                const emotionCell = document.createElement('td');
                emotionCell.className = 'cell emotion-cell';
                
                if (trade.emotion !== null) {
                    emotionCell.textContent = trade.emotion;
                }
                
                emotionCell.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    currentCell = emotionCell;
                    currentTradeIndex = index;
                    currentColumnType = 'emotion';
                    if (emotionModal) emotionModal.style.display = 'flex';
                });
                
                row.appendChild(emotionCell);
                
                const commentsCell = document.createElement('td');
                commentsCell.className = 'cell comments-cell';
                
                if (trade.comment !== '') {
                    commentsCell.textContent = trade.comment;
                } else {
                    commentsCell.textContent = 'Click to add comment';
                    commentsCell.style.color = 'var(--hint-color)';
                    commentsCell.style.fontStyle = 'italic';
                }
                
                commentsCell.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    currentCell = commentsCell;
                    currentTradeIndex = index;
                    currentColumnType = 'comments';
                    if (commentsInput) commentsInput.value = trade.comment || '';
                    if (commentsModal) commentsModal.style.display = 'flex';
                });
                
                row.appendChild(commentsCell);
                
                return row;
            }
            
            // Обновление строки таблицы
            function updateTableRow(row, index, trade) {
                const cells = row.cells;
                
                // Обновляем ячейку с номером сделки
                cells[0].textContent = index + 1;
                
                // Обновляем ячейку с суммой сделки
                const tradeAmountCell = cells[1];
                tradeAmountCell.className = 'cell';
                if (trade.tradeAmount !== null && trade.tradeAmount !== 0) {
                    tradeAmountCell.textContent = formatNumber(trade.tradeAmount);
                    tradeAmountCell.style.color = '';
                    tradeAmountCell.style.fontStyle = '';
                    if (trade.tradeAmount > 0) {
                        tradeAmountCell.classList.add('amount-positive');
                    } else if (trade.tradeAmount < 0) {
                        tradeAmountCell.classList.add('amount-negative');
                    } else {
                        tradeAmountCell.classList.add('amount-zero');
                    }
                } else {
                    tradeAmountCell.textContent = 'Click to enter amount';
                    tradeAmountCell.style.color = 'var(--hint-color)';
                    tradeAmountCell.style.fontStyle = 'italic';
                }
                
                // Обновляем ячейку с результатом
                const resultCell = cells[2];
                resultCell.className = 'cell';

                if (trade.result !== null) {
                    const amount = trade.result.amount;
                    const type = trade.result.type;

                    if (type === 'profit') {
                        resultCell.className += ' profit';
                        if (amount > 0) {
                            resultCell.classList.add('amount-positive');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-negative');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        resultCell.innerHTML = `<div class="cell-content">+${formatNumber(amount)}</div>`;
                    } else if (type === 'loss') {
                        resultCell.className += ' loss';
                        if (amount > 0) {
                            resultCell.classList.add('amount-negative');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-positive');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        resultCell.innerHTML = `<div class="cell-content">-${formatNumber(amount)}</div>`;
                    } else if (type === 'refund') {
                        resultCell.className += ' refund';
                        if (amount > 0) {
                            resultCell.classList.add('amount-positive');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-negative');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        if (amount > 0) {
                            resultCell.innerHTML = `<div class="cell-content">Refund: ${formatNumber(amount)}</div>`;
                        } else {
                            resultCell.innerHTML = `<div class="cell-content">Refund</div>`;
                        }
                    }
                } else {
                    resultCell.innerHTML = '';
                }
                
                // Обновляем ячейку с эмоциями
                const emotionCell = cells[3];
                emotionCell.className = 'cell emotion-cell';
                if (trade.emotion !== null) {
                    emotionCell.textContent = emotionMap[trade.emotion] || trade.emotion;
                } else {
                    emotionCell.textContent = '';
                }
                
                // Обновляем ячейку с комментариями
                const commentsCell = cells[4];
                commentsCell.className = 'cell comments-cell';
                if (trade.comment !== '') {
                    commentsCell.textContent = trade.comment;
                } else {
                    commentsCell.textContent = 'Click to add comment';
                    commentsCell.style.color = 'var(--hint-color)';
                    commentsCell.style.fontStyle = 'italic';
                }
            }
            
            function updateTotal() {
                let total = 0;
                let winTrades = 0;
                let lossTrades = 0;

                for (let i = 0; i < trades.length; i++) {
                    const trade = trades[i];
                    if (trade.result !== null) {
                        const amount = trade.result.amount;
                        const type = trade.result.type;

                        if (type === 'profit') {
                            total += amount;
                            winTrades++;
                        } else if (type === 'loss') {
                            total -= amount;
                            lossTrades++;
                        }
                    }
                }

                // Обновляем результат дня только если это сегодняшний день
                updateDayResultForCurrentDate();

                // Пересчитываем общий баланс с учетом всех сделок и выводов
                recalculateCurrentBalance();

                // Update progress bar
                updateProgressBar();

                // Update percentage indicator
                updatePercentageIndicator();

                const startingBalance = appSettings.startingBalance;
                const profitLossPercent = startingBalance > 0 ? (total / startingBalance) * 100 : 0;

                const dateKey = formatDateKey(currentDate);
                if (!generalData[dateKey]) {
                    generalData[dateKey] = {};
                }

                generalData[dateKey].actualProfitLoss = profitLossPercent;
                generalData[dateKey].winTrades = winTrades;
                generalData[dateKey].lossTrades = lossTrades;

                localStorage.setItem('generalData', JSON.stringify(generalData));

                // Auto save data только если есть данные
                if (hasDayData(trades)) {
                    saveTradeData();
                }

                updateGeneralTable();
                renderHistory();
            }
            
            // Функция для обновления всех данных при изменении в таблице
            function refreshAllDisplays() {
                recalculateCurrentBalance();
                updateDayResultForCurrentDate();
                renderTable();
                renderHistory();
                updateGeneralTable();
                updateProgressBar();
                updatePercentageIndicator();

                // Добавьте сохранение данных
                saveTradeData();
            }
            
            function saveGeneralData() {
                localStorage.setItem('generalData', JSON.stringify(generalData));
            }
            
            function saveWithdrawalData() {
                localStorage.setItem('withdrawalData', JSON.stringify(withdrawalData));
            }
            
            function saveMonthCommentsData() {
                localStorage.setItem('monthCommentsData', JSON.stringify(monthCommentsData));
            }
            
            function updateProgressBarVisibility() {
                const progressBarContainer = document.querySelector('.progress-container');
                if (progressBarContainer) {
                    if (uiSettings.showProgressBar) {
                        progressBarContainer.style.display = 'block';
                    } else {
                        progressBarContainer.style.display = 'none';
                    }
                }
            }
            
            function loadDateData(date) {
                // Сохраняем данные текущего дня перед переходом только если есть данные
                if (hasDayData(trades)) {
                    saveTradeData();
                }
                
                const today = getToday();
                const selectedDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                
                // Prevent navigation to future dates
                if (selectedDate > today) {
                    showNotification("Cannot view future dates", "error");
                    return;
                }
                
                currentDate = date;

                const dateKey = formatDateKey(currentDate);
                
                if (historyData[dateKey]) {
                    // Исправление: глубокое копирование данных для дня
                    tradeData = JSON.parse(JSON.stringify(historyData[dateKey]));
                    trades = tradeData.trades || [];
                } else {
                    tradeData = {};
                    initTrades();
                }
                
                renderTable();
                
                // Update current day label
                updateCurrentDayLabel();
                
                // Calculate balance for the selected day only (don't update the displayed balances)
                let total = 0;
                for (let i = 0; i < trades.length; i++) {
                    const trade = trades[i];
                    if (trade.result !== null) {
                        const amount = trade.result.amount;
                        const type = trade.result.type;
                        
                        if (type === 'profit') {
                            total += amount;
                        } else if (type === 'loss') {
                            total -= amount;
                        }
                    }
                }
                
                // Обновляем результат дня для выбранной даты
                updateDayResultForCurrentDate();
                
                // Обновляем цвет ячейки day result в таблице General
                updateGeneralTable();
                
                // Update progress bar
                updateProgressBar();

                // Update progress bar visibility
                updateProgressBarVisibility();

                // Update percentage indicator
                updatePercentageIndicator();

                // Добавьте сохранение данных
                saveTradeData();

                renderHistory();
                updateGeneralTable();
                updateNavigationButtons();
                updateEditPermissions();

                // Обновляем цвет ячейки day result в баланс-панели при навигации
                updateDayResultDisplay();
            }
            
            // Функция для обновления метки текущего дня
            function updateCurrentDayLabel() {
                if (!currentDayLabel) return;
                
                const today = getToday();
                const current = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                
                if (current.getTime() === today.getTime()) {
                    currentDayLabel.textContent = 'Today';
                } else {
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    
                    if (current.getTime() === yesterday.getTime()) {
                        currentDayLabel.textContent = 'Yesterday';
                    } else {
                        currentDayLabel.textContent = formatDate(currentDate);
                    }
                }
            }
            
            // Функция для проверки, можно ли редактировать текущую дату
            function canEditCurrentDate() {
                const today = getToday();
                const current = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                
                return current.getTime() === today.getTime();
            }
            
            // Функция для обновления прав доступа к редактированию
            function updateEditPermissions() {
                const canEdit = canEditCurrentDate();
                
                // Блокируем/разблокируем ячейки таблицы
                const cells = document.querySelectorAll('#tradingTable td.cell');
                cells.forEach(cell => {
                    if (canEdit) {
                        cell.classList.remove('disabled');
                    } else {
                        cell.classList.add('disabled');
                    }
                });
                
                // Блокируем/разблокируем кнопку добавления сделки
                if (addTradeBtn) {
                    addTradeBtn.disabled = !canEdit;
                }
            }
            
            function updateNavigationButtons() {
                const today = getToday();
                const current = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                
                // Disable next day button if trying to go to future
                if (nextDayBtn) {
                    const nextDay = new Date(current);
                    nextDay.setDate(nextDay.getDate() + 1);
                    
                    if (nextDay > today) {
                        nextDayBtn.disabled = true;
                    } else {
                        nextDayBtn.disabled = false;
                    }
                }
            }
            
            function renderHistory() {
                if (!historyTable) return;
                
                const tbody = historyTable.querySelector('tbody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                const dates = Object.keys(historyData).sort().reverse();
                
                if (dates.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No records in history</td></tr>';
                    return;
                }
                
                dates.forEach(dateKey => {
                    const data = historyData[dateKey];
                    let dayTotal = 0;
                    
                    if (data.trades) {
                        for (let i = 0; i < data.trades.length; i++) {
                            const trade = data.trades[i];
                            if (trade.result !== null) {
                                const amount = trade.result.amount;
                                const type = trade.result.type;
                                
                                if (type === 'profit') {
                                    dayTotal += amount;
                                } else if (type === 'loss') {
                                    dayTotal -= amount;
                                }
                            }
                        }
                    }
                    
                    const row = document.createElement('tr');
                    
                    const dateCell = document.createElement('td');
                    dateCell.textContent = formatDate(parseDateKey(dateKey));
                    row.appendChild(dateCell);
                    
                    const totalCell = document.createElement('td');
                    if (dayTotal > 0) totalCell.classList.add('positive');
                    else if (dayTotal < 0) totalCell.classList.add('negative');
                    totalCell.textContent = formatNumber(dayTotal);
                    row.appendChild(totalCell);
                    
                    tbody.appendChild(row);
                });
            }
            
            function showNotification(message, type) {
                if (!notification) return;

                // Disable all buttons during notification
                const allButtons = document.querySelectorAll('button:not(.modal-btn)');
                allButtons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                });

                // Укоротить сообщение до 6-8 слов
                const words = message.split(' ');
                const shortMessage = words.length > 8 ? words.slice(0, 8).join(' ') + '...' : message;

                notification.textContent = shortMessage;
                notification.className = `notification ${type}`;

                setTimeout(() => {
                    notification.className = 'notification';

                    // Re-enable all buttons after notification
                    allButtons.forEach(btn => {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    });
                }, 3000);
            }
            
            // Functions for General tab
            function initGeneralTab() {
                const now = new Date();
                currentGeneralYear = now.getFullYear();
                currentGeneralMonth = now.getMonth();
                
                console.log('General tab initialized, currentGeneralYear: ' + currentGeneralYear + ', currentGeneralMonth: ' + currentGeneralMonth);
                if (currentGeneralDate) {
                    console.log('currentGeneralDate element: ' + currentGeneralDate.textContent);
                }
                
                updateGeneralNavigation();
                updateGeneralTable();
                renderWithdrawalTable();
                loadMonthComments();
                updateGeneralEditPermissions();
            }
            
            function updateGeneralNavigation() {
                const monthNames = [
                    "January", "February", "March", "April", "May", "June",
                    "July", "August", "September", "October", "November", "December"
                ];
                
                if (currentMonthLabel) {
                    currentMonthLabel.textContent = monthNames[currentGeneralMonth];
                }
                
                if (currentGeneralDate) {
                    // currentGeneralDate.textContent = formatDate(new Date()); // Removed month label
                    console.log('Month label removed from General');
                }
                
                // Update month navigation buttons
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth();
                
                if (nextMonthBtn) {
                    // Disable next month button if we're viewing current month
                    if (currentGeneralYear === currentYear && currentGeneralMonth === currentMonth) {
                        nextMonthBtn.disabled = true;
                    } else {
                        nextMonthBtn.disabled = false;
                    }
                }
            }
            
            function updateGeneralTable() {
                if (!generalTable) return;
                
                const tbody = generalTable.querySelector('tbody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                
                const daysInMonth = new Date(currentGeneralYear, currentGeneralMonth + 1, 0).getDate();
                
                const today = new Date();
                const currentDay = today.getDate();
                const currentMonthIndex = today.getMonth();
                const currentYearValue = today.getFullYear();
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const row = document.createElement('tr');
                    
                    if (day === currentDay && currentGeneralMonth === currentMonthIndex && currentGeneralYear === currentYearValue) {
                        row.classList.add('current-day');
                    }
                    
                    const dayCell = document.createElement('td');
                    dayCell.textContent = day;
                    row.appendChild(dayCell);
                    
                    const profitTargetCell = document.createElement('td');
                    profitTargetCell.className = 'editable';
                    const profitTargetValue = getGeneralData(day, 'profitTarget') || '-';
                    profitTargetCell.textContent = profitTargetValue !== '-' ? profitTargetValue + '%' : '-';
                    profitTargetCell.dataset.day = day;
                    profitTargetCell.dataset.type = 'profit';
                    
                    // Add click event only if we can edit this month
                    if (canEditGeneralMonth()) {
                        profitTargetCell.addEventListener('click', handleTargetCellClick);
                    } else {
                        profitTargetCell.style.cursor = 'not-allowed';
                        profitTargetCell.style.opacity = '0.6';
                    }
                    
                    row.appendChild(profitTargetCell);
                    
                    const lossTargetCell = document.createElement('td');
                    lossTargetCell.className = 'editable';
                    const lossTargetValue = getGeneralData(day, 'lossTarget') || '-';
                    lossTargetCell.textContent = lossTargetValue !== '-' ? lossTargetValue + '%' : '-';
                    lossTargetCell.dataset.day = day;
                    lossTargetCell.dataset.type = 'loss';
                    
                    // Add click event only if we can edit this month
                    if (canEditGeneralMonth()) {
                        lossTargetCell.addEventListener('click', handleTargetCellClick);
                    } else {
                        lossTargetCell.style.cursor = 'not-allowed';
                        lossTargetCell.style.opacity = '0.6';
                    }
                    
                    row.appendChild(lossTargetCell);
                    
                    const actualCell = document.createElement('td');
                    const actualValue = getGeneralData(day, 'actualProfitLoss') || 0;
                    actualCell.textContent = actualValue !== 0 ? actualValue.toFixed(2) + '%' : '-';
                    if (actualValue > 0) {
                        actualCell.classList.add('positive');
                    } else if (actualValue < 0) {
                        actualCell.classList.add('negative');
                    }
                    row.appendChild(actualCell);
                    
                    const winTradesCell = document.createElement('td');
                    const winTrades = getGeneralData(day, 'winTrades') || 0;
                    winTradesCell.textContent = winTrades > 0 ? winTrades : '-';
                    row.appendChild(winTradesCell);
                    
                    const lossTradesCell = document.createElement('td');
                    const lossTrades = getGeneralData(day, 'lossTrades') || 0;
                    lossTradesCell.textContent = lossTrades > 0 ? lossTrades : '-';
                    row.appendChild(lossTradesCell);
                    
                    tbody.appendChild(row);
                }
            }
            
            function getGeneralData(day, field) {
                const dateKey = `${currentGeneralYear}-${String(currentGeneralMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                return generalData[dateKey] ? generalData[dateKey][field] : null;
            }
            
            function handleTargetCellClick(event) {
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot edit past months", "error");
                    return;
                }
                
                const cell = event.target;
                const day = parseInt(cell.dataset.day);
                const type = cell.dataset.type;
                
                currentTargetDay = day;
                currentTargetType = type;
                
                if (targetModalTitle) {
                    targetModalTitle.textContent = `Set ${type === 'profit' ? 'profit target' : 'loss target'} for day ${day} (%)`;
                }
                
                if (targetInput) {
                    const cellText = cell.textContent;
                    targetInput.value = cellText !== '-' ? cellText.replace('%', '') : '';
                }
                
                if (targetModal) {
                    targetModal.style.display = 'flex';
                }
            }
            
            function canEditGeneralMonth() {
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth();
                
                // Can only edit current month
                return currentGeneralYear === currentYear && currentGeneralMonth === currentMonth;
            }
            
            function updateGeneralEditPermissions() {
                const canEdit = canEditGeneralMonth();
                
                // Update withdrawal button
                if (addWithdrawalBtn) {
                    if (canEdit) {
                        addWithdrawalBtn.disabled = false;
                        addWithdrawalBtn.style.opacity = '1';
                    } else {
                        addWithdrawalBtn.disabled = true;
                        addWithdrawalBtn.style.opacity = '0.5';
                    }
                }
                
                // Update month comments
                if (monthCommentsInput) {
                    monthCommentsInput.disabled = !canEdit;
                    if (!canEdit) {
                        monthCommentsInput.placeholder = "Cannot edit comments for past months";
                    } else {
                        monthCommentsInput.placeholder = "Enter comments for the current month...";
                    }
                }
            }
            
            function loadGeneralMonth(year, month) {
                currentGeneralYear = year;
                currentGeneralMonth = month;
                
                updateGeneralNavigation();
                updateGeneralTable();
                renderWithdrawalTable();
                loadMonthComments();
                updateGeneralEditPermissions();
            }
            
            function addWithdrawal(amount) {
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot add withdrawals to past months", "error");
                    return;
                }

                const today = getToday();
                const dateKey = formatDateKey(today);
                if (!withdrawalData[dateKey]) {
                    withdrawalData[dateKey] = [];
                }

                withdrawalData[dateKey].push({
                    date: dateKey,
                    amount: amount
                });

                // Вместо прямого изменения баланса, пересчитываем его полностью
                recalculateCurrentBalance();

                saveWithdrawalData();
                saveSettings();
                renderWithdrawalTable();

                // Update percentage indicator after withdrawal
                updatePercentageIndicator();

                showNotification(`Withdrawal ${formatNumber(amount)} saved successfully`, 'success');
            }
            
            function editWithdrawal(dateKey, index, newAmount) {
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot edit withdrawals in past months", "error");
                    return;
                }

                if (!withdrawalData[dateKey] || !withdrawalData[dateKey][index]) return;

                const oldAmount = withdrawalData[dateKey][index].amount;
                withdrawalData[dateKey][index].amount = newAmount;

                // Вместо прямого изменения баланса, пересчитываем его полностью
                recalculateCurrentBalance();

                saveWithdrawalData();
                saveSettings();
                renderWithdrawalTable();

                // Update percentage indicator after withdrawal edit
                updatePercentageIndicator();

                showNotification(`Withdrawal updated to ${formatNumber(newAmount)}`, 'success');
            }
            
            function deleteWithdrawal(dateKey, index) {
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot delete withdrawals from past months", "error");
                    return;
                }

                if (!withdrawalData[dateKey] || !withdrawalData[dateKey][index]) return;

                const amount = withdrawalData[dateKey][index].amount;

                withdrawalData[dateKey].splice(index, 1);

                if (withdrawalData[dateKey].length === 0) {
                    delete withdrawalData[dateKey];
                }

                // Вместо прямого изменения баланса, пересчитываем его полностью
                recalculateCurrentBalance();

                saveWithdrawalData();
                saveSettings();
                renderWithdrawalTable();

                // Update percentage indicator after withdrawal deletion
                updatePercentageIndicator();

                showNotification(`Withdrawal ${formatNumber(amount)} deleted`, 'success');
            }
            
            function renderWithdrawalTable() {
                if (!withdrawalTable) return;
                
                const tbody = withdrawalTable.querySelector('tbody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                
                const currentMonthKey = `${currentGeneralYear}-${String(currentGeneralMonth + 1).padStart(2, '0')}`;
                let totalWithdrawal = 0;
                let hasWithdrawals = false;
                
                Object.keys(withdrawalData).forEach(dateKey => {
                    if (dateKey.startsWith(currentMonthKey)) {
                        withdrawalData[dateKey].forEach((withdrawal, index) => {
                            hasWithdrawals = true;
                            const row = document.createElement('tr');
                            row.className = 'editable';
                            row.dataset.date = dateKey;
                            row.dataset.index = index;
                            
                            const dateCell = document.createElement('td');
                            dateCell.textContent = formatDate(parseDateKey(withdrawal.date));
                            row.appendChild(dateCell);
                            
                            const amountCell = document.createElement('td');
                            amountCell.textContent = formatNumber(withdrawal.amount);
                            row.appendChild(amountCell);
                            
                            // Only allow editing if we can edit this month
                            if (canEditGeneralMonth()) {
                                row.addEventListener('click', (e) => {
                                    currentWithdrawalDate = e.currentTarget.dataset.date;
                                    currentWithdrawalIndex = parseInt(e.currentTarget.dataset.index);
                                    
                                    if (withdrawalActionModal) {
                                        withdrawalActionModal.style.display = 'flex';
                                    }
                                });
                            } else {
                                row.style.cursor = 'not-allowed';
                                row.style.opacity = '0.6';
                            }
                            
                            tbody.appendChild(row);
                            
                            totalWithdrawal += withdrawal.amount;
                        });
                    }
                });
                
                if (!hasWithdrawals) {
                    const emptyRow = document.createElement('tr');
                    const emptyCell = document.createElement('td');
                    emptyCell.colSpan = 2;
                    emptyCell.textContent = 'No withdrawals for this month';
                    emptyCell.style.textAlign = 'center';
                    emptyCell.style.fontStyle = 'italic';
                    emptyCell.style.color = 'var(--hint-color)';
                    emptyRow.appendChild(emptyCell);
                    tbody.appendChild(emptyRow);
                } else if (totalWithdrawal > 0) {
                    const totalRow = document.createElement('tr');
                    totalRow.style.fontWeight = 'bold';
                    
                    const totalLabelCell = document.createElement('td');
                    totalLabelCell.textContent = 'Total:';
                    totalRow.appendChild(totalLabelCell);
                    
                    const totalAmountCell = document.createElement('td');
                    totalAmountCell.textContent = formatNumber(totalWithdrawal);
                    totalRow.appendChild(totalAmountCell);
                    
                    tbody.appendChild(totalRow);
                }
            }
            
            function applyTargetToDay(value) {
                if (!currentTargetDay || !currentTargetType) return;
                
                const dateKey = `${currentGeneralYear}-${String(currentGeneralMonth + 1).padStart(2, '0')}-${String(currentTargetDay).padStart(2, '0')}`;
                
                if (!generalData[dateKey]) {
                    generalData[dateKey] = {};
                }
                
                generalData[dateKey][currentTargetType + 'Target'] = parseFloat(value);
                
                localStorage.setItem('generalData', JSON.stringify(generalData));
                updateGeneralTable();
                
                if (targetModal) {
                    targetModal.style.display = 'none';
                }
                
                showNotification(`Target for day ${currentTargetDay} set`, 'success');
            }
            
            function applyTargetToAll(value) {
                if (!currentTargetType) return;
                
                const daysInMonth = new Date(currentGeneralYear, currentGeneralMonth + 1, 0).getDate();
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateKey = `${currentGeneralYear}-${String(currentGeneralMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    
                    if (!generalData[dateKey]) {
                        generalData[dateKey] = {};
                    }
                    
                    generalData[dateKey][currentTargetType + 'Target'] = parseFloat(value);
                }
                
                saveGeneralData();
                updateGeneralTable();
                
                closeModal();
                
                showNotification(`Targets for all days set (${value}%)`, 'success');
            }
            
            function loadMonthComments() {
                if (!monthCommentsInput) return;
                
                const monthKey = `${currentGeneralYear}-${currentGeneralMonth + 1}`;
                monthCommentsInput.value = monthCommentsData[monthKey] || '';
            }
            
            function saveMonthComments() {
                if (!monthCommentsInput) return;
                
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot edit comments for past months", "error");
                    return;
                }
                
                const monthKey = `${currentGeneralYear}-${currentGeneralMonth + 1}`;
                monthCommentsData[monthKey] = monthCommentsInput.value;
                saveMonthCommentsData();
            }

            // Event Listeners
            if (prevDayBtn) {
                prevDayBtn.addEventListener('click', () => {
                    const newDate = new Date(currentDate);
                    newDate.setDate(newDate.getDate() - 1);
                    loadDateData(newDate);
                });
            }
            
            if (currentDayLabel) {
                currentDayLabel.addEventListener('click', () => {
                    loadDateData(getToday());
                });
            }
            
            if (nextDayBtn) {
                nextDayBtn.addEventListener('click', () => {
                    const newDate = new Date(currentDate);
                    newDate.setDate(newDate.getDate() + 1);
                    loadDateData(newDate);
                });
            }
            
            // Month navigation for General tab
            if (prevMonthBtn) {
                prevMonthBtn.addEventListener('click', () => {
                    let newMonth = currentGeneralMonth - 1;
                    let newYear = currentGeneralYear;
                    
                    if (newMonth < 0) {
                        newMonth = 11;
                        newYear--;
                    }
                    
                    loadGeneralMonth(newYear, newMonth);
                });
            }
            
            if (nextMonthBtn) {
                nextMonthBtn.addEventListener('click', () => {
                    const now = new Date();
                    const currentYear = now.getFullYear();
                    const currentMonth = now.getMonth();
                    
                    // Prevent navigation to future months
                    if (currentGeneralYear === currentYear && currentGeneralMonth === currentMonth) {
                        showNotification("Cannot view future months", "error");
                        return;
                    }
                    
                    let newMonth = currentGeneralMonth + 1;
                    let newYear = currentGeneralYear;
                    
                    if (newMonth > 11) {
                        newMonth = 0;
                        newYear++;
                    }
                    
                    // Check if we're trying to navigate to a future month
                    if (newYear > currentYear || (newYear === currentYear && newMonth > currentMonth)) {
                        showNotification("Cannot view future months", "error");
                        return;
                    }
                    
                    loadGeneralMonth(newYear, newMonth);
                });
            }
            
            if (addTradeBtn) {
                addTradeBtn.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    addTradeToTable();
                    // Не сохраняем автоматически при добавлении пустой сделки
                });
            }
            
            if (addWithdrawalBtn) {
                addWithdrawalBtn.addEventListener('click', () => {
                    // Check if we can edit this month
                    if (!canEditGeneralMonth()) {
                        showNotification("Cannot add withdrawals to past months", "error");
                        return;
                    }
                    
                    isEditingWithdrawal = false;
                    if (withdrawalAmountInput) withdrawalAmountInput.value = '';
                    if (withdrawalModal) withdrawalModal.style.display = 'flex';
                });
            }
            
            if (monthCommentsInput) {
                monthCommentsInput.addEventListener('change', saveMonthComments);
                monthCommentsInput.addEventListener('blur', saveMonthComments);
            }
            
            // Remove conflicting event listeners that were causing issues
            // with reset and clear buttons
            
            // Закрытие модальных окон по клавише Escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeModal();
                }
            });

            if (clearCurrentDayBtn) {
                clearCurrentDayBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to clear current day data?')) {
                        const dateKey = formatDateKey(currentDate);
                        delete historyData[dateKey];
                        saveTradeData();
                        
                        initTrades();
                        renderTable();
                        updateTotal();
                        
                        showNotification('Current day data cleared', 'success');
                    }
                });
            }
            
            if (clearAllDataBtn) {
                clearAllDataBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to clear ALL history? This action cannot be undone.')) {
                        historyData = {};
                        generalData = {};
                        withdrawalData = {};
                        monthCommentsData = {};
                        appSettings = {
                            initialBalance: 10000,
                            startingBalance: 10000,
                            currentBalance: 10000
                        };

                        saveTradeData();
                        saveGeneralData();
                        saveWithdrawalData();
                        saveMonthCommentsData();
                        saveSettings();

                        if (balanceAmount) balanceAmount.textContent = '10000';
                        if (currentBalanceValue) currentBalanceValue.textContent = '10000';

                        initTrades();
                        renderTable();
                        updateTotal();
                        renderHistory();
                        renderWithdrawalTable();
                        updateGeneralTable();

                        // Update percentage indicator immediately after clearing all data
                        console.log('About to call updatePercentageIndicator() after clearing all data');
                        updatePercentageIndicator();
                        console.log('updatePercentageIndicator() called after clearing all data');

                        showNotification('All history cleared', 'success');
                    }
                });
            }
            
            // Modal event listeners - ИСПРАВЛЕННЫЕ ОБРАБОТЧИКИ
            const resultModalButtons = resultModal?.querySelectorAll('.modal-btn');
            if (resultModalButtons) {
                resultModalButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        
                        const value = button.dataset.value;
                        const amount = parseFloat(amountInput?.value.replace(',', '.'));
                        
                        if (currentTradeIndex !== null && value === 'reset') {
                            trades[currentTradeIndex].result = null;
                            currentCell.className = 'cell';
                            currentCell.innerHTML = '';
                            
                            updateTotal();
                            refreshAllDisplays();
                            closeModal();
                        } else if (currentTradeIndex !== null && value === 'refund') {
                            currentCell.className = 'cell refund';
                            if (!isNaN(amount) && amount > 0) {
                                currentCell.innerHTML = `<div class="cell-content">Refund: ${formatNumber(amount)}</div>`;
                                trades[currentTradeIndex].result = { type: 'refund', amount: amount };
                            } else {
                                currentCell.innerHTML = `<div class="cell-content">Refund</div>`;
                                trades[currentTradeIndex].result = { type: 'refund', amount: 0 };
                            }
                            
                            updateTotal();
                            refreshAllDisplays();
                            closeModal();
                        } else if (currentTradeIndex !== null && !isNaN(amount) && amount > 0) {
                            if (value === 'profit') {
                                currentCell.className = 'cell profit';
                                currentCell.innerHTML = `<div class="cell-content">+${formatNumber(amount)}</div>`;
                                trades[currentTradeIndex].result = { type: 'profit', amount: amount };
                            } else if (value === 'loss') {
                                currentCell.className = 'cell loss';
                                currentCell.innerHTML = `<div class="cell-content">-${formatNumber(amount)}</div>`;
                                trades[currentTradeIndex].result = { type: 'loss', amount: amount };
                            }
                            
                            updateTotal();
                            refreshAllDisplays();
                            closeModal();
                        } else if (currentTradeIndex !== null && value !== 'reset' && value !== 'refund') {
                            showNotification('Enter a valid positive amount', 'error');
                            if (amountInput) {
                                amountInput.classList.add('error-input');
                                setTimeout(() => amountInput.classList.remove('error-input'), 10);
                            }
                            // НЕ закрываем модальное окно при ошибке
                            return;
                        } else if (currentTradeIndex === null) {
                            showNotification('No trade selected', 'error');
                            closeModal();
                            return;
                        }
                    });
                });
            }
            
            if (resultModal) {
                resultModal.addEventListener('click', (e) => {
                    if (e.target === resultModal) {
                        closeModal();
                    }
                });
            }
            
            // Close modal when pressing Enter in amount input
            if (amountInput) {
                amountInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        // Trigger the first button's action (profit)
                        const profitBtn = document.querySelector('.profit-btn[data-value]');
                        if (profitBtn) {
                            profitBtn.click();
                        }
                    }
                });
            }
            
            // ИСПРАВЛЕННЫЙ ОБРАБОТЧИК для сохранения суммы сделки
            if (saveTradeAmountBtn) {
                saveTradeAmountBtn.addEventListener('click', () => {
                    // Валидация введенных данных
                    const inputValue = tradeAmountInput?.value?.trim();
                    
                    // Если поле пустое или значение равно 0, сбрасываем сумму сделки
                    if (!inputValue || inputValue === '0') {
                        trades[currentTradeIndex].tradeAmount = null;
                        currentCell.textContent = 'Click to enter amount';
                        currentCell.style.color = 'var(--hint-color)';
                        currentCell.style.fontStyle = 'italic';
                    } else {
                        const amount = parseFloat(inputValue.replace(',', '.'));
                        if (isNaN(amount)) {
                            showNotification('Please enter a valid number', 'error');
                            return;
                        }
                        
                        if (amount <= 0) {
                            showNotification('Trade amount must be greater than 0', 'error');
                            return;
                        }
                        
                        // Проверка на слишком большое значение
                        if (amount > 100000) { // 100,000
                            showNotification('Trade amount is too large', 'error');
                            return;
                        }
                        
                        trades[currentTradeIndex].tradeAmount = amount;
                        currentCell.textContent = formatNumber(amount);
                        currentCell.style.color = '';
                        currentCell.style.fontStyle = '';
                    }
                    
                    saveTradeData();
                    updateTotal();
                    refreshAllDisplays();
                    closeModal();
                });
            }
            
            // Валидация ввода в поле суммы сделки (реальное время)
            if (tradeAmountInput) {
                tradeAmountInput.addEventListener('input', function() {
                    // Убираем все, кроме цифр, точки и запятой
                    this.value = this.value.replace(/[^0-9.,]/g, '');
                });
            }

            // Валидация ввода в поле суммы результата (реальное время)
            if (amountInput) {
                amountInput.addEventListener('input', function() {
                    // Убираем все, кроме цифр, точки и запятой
                    this.value = this.value.replace(/[^0-9.,]/g, '');
                });
            }
            
            if (cancelTradeAmountBtn) {
                cancelTradeAmountBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (tradeAmountModal) {
                tradeAmountModal.addEventListener('click', (e) => {
                    if (e.target === tradeAmountModal) {
                        closeModal();
                    }
                });
            }
            
            // Close trade amount modal when pressing Enter in trade amount input
            if (tradeAmountInput) {
                tradeAmountInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (saveTradeAmountBtn) saveTradeAmountBtn.click();
                    }
                });
            }
            
            // ИСПРАВЛЕНИЕ: Правильная обработка сохранения вывода (добавление или редактирование)
            if (saveWithdrawalBtn) {
                saveWithdrawalBtn.addEventListener('click', () => {
                    const amount = parseFloat(withdrawalAmountInput?.value.replace(',', '.'));
                    if (!isNaN(amount) && amount > 0) {
                        if (isEditingWithdrawal && currentWithdrawalDate !== null && currentWithdrawalIndex !== null) {
                            editWithdrawal(currentWithdrawalDate, currentWithdrawalIndex, amount);
                        } else {
                            addWithdrawal(amount);
                        }
                        isEditingWithdrawal = false;
                        closeModal();
                    } else {
                        showNotification('Enter a valid positive amount', 'error');
                        if (withdrawalAmountInput) {
                            withdrawalAmountInput.classList.add('error-input');
                            setTimeout(() => withdrawalAmountInput.classList.remove('error-input'), 1000);
                        }
                    }
                });
            }
            
            if (cancelWithdrawalBtn) {
                cancelWithdrawalBtn.addEventListener('click', () => {
                    isEditingWithdrawal = false;
                    closeModal();
                });
            }
            
            if (withdrawalModal) {
                withdrawalModal.addEventListener('click', (e) => {
                    if (e.target === withdrawalModal) {
                        isEditingWithdrawal = false;
                        closeModal();
                    }
                });
            }
            
            // Close withdrawal modal when pressing Enter in withdrawal amount input
            if (withdrawalAmountInput) {
                withdrawalAmountInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (saveWithdrawalBtn) saveWithdrawalBtn.click();
                    }
                });
            }
            
            // ИСПРАВЛЕНИЕ: Установка флага редактирования при нажатии на Edit
            if (editWithdrawalBtn) {
                editWithdrawalBtn.addEventListener('click', () => {
                    if (currentWithdrawalDate !== null && currentWithdrawalIndex !== null) {
                        isEditingWithdrawal = true;
                        const withdrawal = withdrawalData[currentWithdrawalDate][currentWithdrawalIndex];
                        if (withdrawalAmountInput) withdrawalAmountInput.value = withdrawal.amount;
                        if (withdrawalModal) withdrawalModal.style.display = 'flex';
                        if (withdrawalActionModal) withdrawalActionModal.style.display = 'none';
                    }
                });
            }
            
            if (deleteWithdrawalBtn) {
                deleteWithdrawalBtn.addEventListener('click', () => {
                    if (currentWithdrawalDate !== null && currentWithdrawalIndex !== null) {
                        deleteWithdrawal(currentWithdrawalDate, currentWithdrawalIndex);
                        if (withdrawalActionModal) withdrawalActionModal.style.display = 'none';
                    }
                });
            }
            
            if (cancelWithdrawalActionBtn) {
                cancelWithdrawalActionBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (withdrawalActionModal) {
                withdrawalActionModal.addEventListener('click', (e) => {
                    if (e.target === withdrawalActionModal) {
                        closeModal();
                    }
                });
            }
            
            // Close withdrawal action modal when pressing Enter
            withdrawalActionModal.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    withdrawalActionModal.style.display = 'none';
                }
            });
            
            const emotionOptions = emotionModal?.querySelectorAll('.emotion-option');
            if (emotionOptions) {
                emotionOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const emotion = option.dataset.emotion;
                        trades[currentTradeIndex].emotion = emotion;
                        // Display using emotion map
                        currentCell.textContent = emotionMap[emotion];
                        saveTradeData();
                        updateTotal();
                        refreshAllDisplays();
                        closeModal();
                    });
                });
            }
            
            // Close emotion modal when clicking outside
            if (emotionModal) {
                emotionModal.addEventListener('click', (e) => {
                    if (e.target === emotionModal) {
                        closeModal();
                    }
                });
            }
            
            if (clearEmotionBtn) {
                clearEmotionBtn.addEventListener('click', () => {
                    trades[currentTradeIndex].emotion = null;
                    currentCell.textContent = '';
                    saveTradeData();
                    updateTotal();
                    refreshAllDisplays();
                    closeModal();
                });
            }
            
            // Close emotion modal when pressing Enter in emotion modal
            if (emotionModal) {
                emotionModal.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        closeModal();
                    }
                });
            }
            
            
            if (saveCommentBtn) {
                saveCommentBtn.addEventListener('click', () => {
                    trades[currentTradeIndex].comment = commentsInput.value;
                    currentCell.textContent = commentsInput.value;
                    currentCell.style.color = '';
                    currentCell.style.fontStyle = '';
                    saveTradeData();
                    updateTotal();
                    refreshAllDisplays();
                    closeModal();
                });
            }
            
            if (cancelCommentBtn) {
                cancelCommentBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (commentsModal) {
                commentsModal.addEventListener('click', (e) => {
                    if (e.target === commentsModal) {
                        closeModal();
                    }
                });
            }
            
            // Close comments modal when pressing Enter in comments input
            if (commentsInput) {
                commentsInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (saveCommentBtn) saveCommentBtn.click();
                    }
                });
            }
            
            if (startingBalanceValue) {
                startingBalanceValue.addEventListener('click', () => {
                    console.log('Starting Balance clicked');
                    console.log('Modal display before:', balanceModal ? balanceModal.style.display : 'null');
                    if (balanceInput) balanceInput.value = appSettings.startingBalance;
                    if (balanceModal) balanceModal.style.display = 'flex';
                    console.log('Modal display after:', balanceModal ? balanceModal.style.display : 'null');
                });
            }
            
            if (saveBalanceBtn) {
                saveBalanceBtn.addEventListener('click', () => {
                    const inputValue = balanceInput.value.replace(',', '.');
                    const newBalance = parseFloat(inputValue);
                    if (!isNaN(newBalance)) {
                        appSettings.startingBalance = newBalance;
                        appSettings.currentBalance = newBalance;

                        if (balanceAmount) {
                            balanceAmount.textContent = formatNumber(newBalance);
                        }

                        if (currentBalanceValue) {
                            currentBalanceValue.textContent = formatNumber(newBalance);
                        }

                        updateTotal();
                        saveSettings();

                        // Update percentage indicator after balance change
                        updatePercentageIndicator();

                        if (balanceModal) balanceModal.style.display = 'none';

                        showNotification('Balance updated', 'success');
                    } else {
                        showNotification('Enter a valid number', 'error');
                    }
                });
            }
            
            if (cancelBalanceBtn) {
                cancelBalanceBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (balanceModal) {
                balanceModal.addEventListener('click', (e) => {
                    if (e.target === balanceModal) {
                        closeModal();
                    }
                });
            }
            
            // Close balance modal when pressing Enter in balance input
            if (balanceInput) {
                balanceInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (saveBalanceBtn) saveBalanceBtn.click();
                    }
                });
            }
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.dataset.tab;
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const tabContent = document.getElementById(`${tabId}-tab`);
                    if (tabContent) tabContent.classList.add('active');
                    
                    if (tabId === 'general') {
                        // Reset to current month when switching to General tab
                        const now = new Date();
                        loadGeneralMonth(now.getFullYear(), now.getMonth());
                    } else if (tabId === 'table') {
                        updateProgressBar();
                        // Обновляем цвет ячейки day result при переключении на вкладку "table"
                        updateDayResultForCurrentDate();
                    }
                });
            });
            
            if (applyToDayBtn) {
                applyToDayBtn.addEventListener('click', () => {
                    // Валидация введенных данных
                    const inputValue = targetInput?.value?.trim();
                    if (!inputValue) {
                        showNotification('Please enter a target value', 'error');
                        return;
                    }
                    
                    const value = parseFloat(inputValue.replace(',', '.'));
                    if (isNaN(value)) {
                        showNotification('Please enter a valid number', 'error');
                        return;
                    }
                    
                    // Проверка на разумные пределы целевого значения
                    if (Math.abs(value) > 100) {
                        showNotification('Target value seems too high (max ±100%)', 'error');
                        return;
                    }
                    
                    applyTargetToDay(value);
                });
            }
            
            if (applyToAllBtn) {
                applyToAllBtn.addEventListener('click', () => {
                    // Валидация введенных данных
                    const inputValue = targetInput?.value?.trim();
                    if (!inputValue) {
                        showNotification('Please enter a target value', 'error');
                        return;
                    }
                    
                    const value = parseFloat(inputValue.replace(',', '.'));
                    if (isNaN(value)) {
                        showNotification('Please enter a valid number', 'error');
                        return;
                    }
                    
                    // Проверка на разумные пределы целевого значения
                    if (Math.abs(value) > 100) {
                        showNotification('Target value seems too high (max ±100%)', 'error');
                        return;
                    }
                    
                    applyTargetToAll(value);
                });
            }
            
            // Валидация ввода в поле целевого значения (реальное время)
            if (targetInput) {
                targetInput.addEventListener('input', function() {
                    // Убираем все, кроме цифр, точки, запятой и минуса (для отрицательных значений)
                    this.value = this.value.replace(/[^0-9.,-]/g, '');
                });
            }
            
            if (cancelTargetBtn) {
                cancelTargetBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (targetModal) {
                targetModal.addEventListener('click', (e) => {
                    if (e.target === targetModal) {
                        closeModal();
                    }
                });
            }
            
            // Универсальная функция для закрытия модальных окон
            function closeModal() {
                // Закрываем все возможные модальные окна
                const modals = [
                    resultModal,
                    tradeAmountModal,
                    withdrawalModal,
                    withdrawalActionModal,
                    emotionModal,
                    commentsModal,
                    balanceModal,
                    targetModal
                ];
                
                modals.forEach(modal => {
                    if (modal) {
                        modal.style.display = 'none';
                    }
                });
                
                // Сбрасываем переменные состояния
                currentCell = null;
                currentTradeIndex = null;
                currentColumnType = null;
                currentTargetDay = null;
                currentTargetType = null;
                currentWithdrawalDate = null;
                currentWithdrawalIndex = null;
                
                // Сбрасываем значения полей ввода
                if (amountInput) amountInput.value = '';
                if (tradeAmountInput) tradeAmountInput.value = '';
                if (withdrawalAmountInput) withdrawalAmountInput.value = '';
                if (balanceInput) balanceInput.value = '';
                if (targetInput) targetInput.value = '';
                if (commentsInput) commentsInput.value = '';
            }

            // Функция для обновления прогресс-бара
            function updateProgressBar() {
                console.log('updateProgressBar called');
                if (!progressFill || !progressStart || !progressCurrent || !progressTarget) {
                    console.log('Progress bar elements not found');
                    return;
                }

                // Получаем текущую дату
                const currentDateKey = formatDateKey(currentDate);

                // Получаем данные о целях для текущего дня
                const dayGeneralData = generalData[currentDateKey] || {};
                const profitTarget = dayGeneralData.profitTarget || 2; // По умолчанию 2%
                const lossTarget = dayGeneralData.lossTarget || -2; // По умолчанию -2%

                // Вычисляем результат за текущий день
                let dayResult = 0;
                let dayResultPercent = 0;

                // Используем текущие данные trades для текущей даты, а не historyData для актуальности
                if (currentDateKey === formatDateKey(new Date())) {
                    // Для текущей даты используем актуальные данные из переменной trades
                    for (let i = 0; i < trades.length; i++) {
                        const trade = trades[i];
                        if (trade.result) {
                            if (trade.result.type === 'profit') {
                                dayResult += trade.result.amount;
                            } else if (trade.result.type === 'loss') {
                                dayResult -= trade.result.amount;
                            }
                        }
                    }
                } else {
                    // Для других дат используем данные из historyData
                    if (historyData[currentDateKey] && historyData[currentDateKey].trades) {
                        historyData[currentDateKey].trades.forEach(trade => {
                            if (trade.result) {
                                if (trade.result.type === 'profit') {
                                    dayResult += trade.result.amount;
                                } else if (trade.result.type === 'loss') {
                                    dayResult -= trade.result.amount;
                                }
                            }
                        });
                    }
                }

                // Вычисляем процент результата относительно начального баланса дня
                if (appSettings.startingBalance > 0) {
                    dayResultPercent = (dayResult / appSettings.startingBalance) * 100;
                }

                // Обновляем UI элементы
                progressStart.textContent = `${lossTarget.toFixed(1)}%`;
                progressCurrent.textContent = `${dayResultPercent.toFixed(1)}%`;
                progressTarget.textContent = `${profitTarget.toFixed(1)}%`;

                // Создаем контейнер для прогресс-бара, чтобы корректно отображать двунаправленный прогресс
                const progressBar = document.querySelector('.progress-bar');

                // Очищаем предыдущие элементы прогресса, если они есть
                const existingLossFill = document.querySelector('.progress-loss-fill');
                const existingProfitFill = document.querySelector('.progress-profit-fill');
                const centerMarker = document.querySelector('.center-marker');

                if (existingLossFill) existingLossFill.remove();
                if (existingProfitFill) existingProfitFill.remove();
                if (centerMarker) centerMarker.remove();

                // Создаем отдельные элементы для отрицательного (убыток) и положительного (прибыль) прогресса
                if (dayResultPercent < 0) {
                    // Красная часть (убыток) - от центра влево
                    const lossFill = document.createElement('div');
                    lossFill.className = 'progress-loss-fill';
                    const lossPercentage = (Math.abs(dayResultPercent) / Math.abs(lossTarget)) * 50;
                    lossFill.style.width = `${Math.min(50, Math.max(0, lossPercentage))}%`;
                    lossFill.style.background = 'var(--progress-loss)';
                    lossFill.style.height = '100%';
                    lossFill.style.position = 'absolute';
                    lossFill.style.left = `${50 - lossPercentage}%`;
                    lossFill.style.top = '0';
                    lossFill.style.borderRadius = '6px';
                    progressBar.appendChild(lossFill);
                } else if (dayResultPercent > 0) {
                    // Зеленая часть (прибыль) - от центра вправо
                    const profitFill = document.createElement('div');
                    profitFill.className = 'progress-profit-fill';
                    const profitPercentage = (dayResultPercent / profitTarget) * 50;
                    profitFill.style.width = `${Math.min(50, Math.max(0, profitPercentage))}%`;
                    profitFill.style.background = 'var(--progress-profit)';
                    profitFill.style.height = '100%';
                    profitFill.style.position = 'absolute';
                    profitFill.style.left = '50%';
                    profitFill.style.top = '0';
                    profitFill.style.borderRadius = '6px';
                    progressBar.appendChild(profitFill);
                }

                // Центральная метка (0%)
                const marker = document.createElement('div');
                marker.className = 'center-marker';
                marker.style.position = 'absolute';
                marker.style.left = '50%';
                marker.style.top = '0';
                marker.style.height = '100%';
                marker.style.width = '2px';
                marker.style.background = 'var(--text-color)';
                marker.style.transform = 'translateX(-50%)';
                marker.style.zIndex = '2';
                progressBar.appendChild(marker);

                // Убираем основной элемент прогресс-бара, так как теперь у нас двунаправленный прогресс
                progressFill.style.width = '0%';
                console.log('Progress bar updated successfully');
            }

            // Обновляем функцию updatePercentageIndicator с цветами и одним знаком после запятой для процентов
            function updatePercentageIndicator() {
                console.log('updatePercentageIndicator() called');

                if (!percentageIndicator || !indicatorArrow || !indicatorPercentage || !balanceAmount) {
                    return;
                }

                const startingBalance = appSettings.startingBalance;

                // Рассчитываем текущий баланс только на основе торговой истории
                let tradingProfitLoss = 0;

                Object.keys(historyData).forEach(dateKey => {
                    const dayData = historyData[dateKey];
                    if (dayData.trades) {
                        dayData.trades.forEach(trade => {
                            if (trade.result) {
                                if (trade.result.type === 'profit') {
                                    tradingProfitLoss += trade.result.amount;
                                } else if (trade.result.type === 'loss') {
                                    tradingProfitLoss -= trade.result.amount;
                                }
                            }
                        });
                    }
                });

                const currentDateKey = formatDateKey(currentDate);
                if (trades && trades.length > 0) {
                    const hasSavedData = historyData[currentDateKey] && historyData[currentDateKey].trades;
                    if (!hasSavedData) {
                        trades.forEach(trade => {
                            if (trade.result) {
                                if (trade.result.type === 'profit') {
                                    tradingProfitLoss += trade.result.amount;
                                } else if (trade.result.type === 'loss') {
                                    tradingProfitLoss -= trade.result.amount;
                                }
                            }
                        });
                    }
                }

                const currentTradingBalance = startingBalance + tradingProfitLoss;

                let percentageChange;
                if (startingBalance === 0) {
                    percentageChange = 0;
                } else {
                    percentageChange = ((currentTradingBalance - startingBalance) / startingBalance) * 100;
                }

                // Округляем до одного знака после запятой
                const roundedPercentage = Math.round(percentageChange * 10) / 10;

                // Форматируем отображение процента с одним знаком после запятой
                let displayPercentage;
                if (Math.abs(roundedPercentage) < 0.1) {
                    displayPercentage = '0.0%';
                } else {
                    displayPercentage = (roundedPercentage > 0 ? '+' : '') + roundedPercentage.toFixed(1) + '%';
                }

                // Обрезаем до 5 символов если нужно (например: +12.3%)
                if (displayPercentage.length > 5) {
                    // Для значений больше 99.9% показываем целое число
                    displayPercentage = (roundedPercentage > 0 ? '+' : '') + Math.round(roundedPercentage) + '%';
                }

                // Update percentage text
                indicatorPercentage.textContent = displayPercentage;

                // Update arrow and colors - используем широкие толстые символы с цветами
                if (roundedPercentage > 0) {
                    // ЗЕЛЕНЫЙ для плюса
                    indicatorArrow.textContent = '▲';
                    indicatorArrow.className = 'indicator-arrow positive';
                    indicatorPercentage.className = 'indicator-percentage positive';
                } else if (roundedPercentage < 0) {
                    // КРАСНЫЙ для минуса
                    indicatorArrow.textContent = '▼';
                    indicatorArrow.className = 'indicator-arrow negative';
                    indicatorPercentage.className = 'indicator-percentage negative';
                } else {
                    // Нейтральный цвет для нуля
                    indicatorArrow.textContent = '●';
                    indicatorArrow.className = 'indicator-arrow neutral';
                    indicatorPercentage.className = 'indicator-percentage neutral';
                }

                // Always show the indicator
                percentageIndicator.style.display = 'flex';

                // Обновляем отображение суммы баланса
                updateBalanceDisplay();

                console.log('Percentage indicator updated:', {
                    percentage: roundedPercentage,
                    display: displayPercentage,
                    arrowColor: indicatorArrow.className,
                    percentageColor: indicatorPercentage.className
                });
            }

            // Функция для форматирования суммы баланса с двумя знаками после запятой
            function formatBalanceForDisplay(number) {
                if (number >= 1000000) {
                    // Формат: 1.23M
                    return (number / 1000000).toFixed(2) + 'M';
                } else if (number >= 100000) {
                    // Формат: 123.45K
                    return (number / 1000).toFixed(2) + 'K';
                } else if (number >= 10000) {
                    // Формат: 10.23K
                    return (number / 1000).toFixed(2) + 'K';
                } else if (number >= 1000) {
                    // Формат: 1.23K
                    return (number / 1000).toFixed(2) + 'K';
                } else {
                    // Формат: 123.45
                    return number.toFixed(2);
                }
            }

            function updateBalanceDisplay() {
                if (!balanceAmount) return;

                const startingBalance = appSettings.startingBalance;
                const formattedBalance = formatBalanceForDisplay(startingBalance);

                // Проверяем что не превышаем 7 символов
                if (formattedBalance.length > 7) {
                    // Если превышает, используем более агрессивное форматирование
                    if (startingBalance >= 1000000) {
                        balanceAmount.textContent = Math.round(startingBalance / 1000000) + 'M';
                    } else if (startingBalance >= 1000) {
                        balanceAmount.textContent = Math.round(startingBalance / 1000) + 'K';
                    } else {
                        balanceAmount.textContent = Math.round(startingBalance).toString();
                    }
                } else {
                    balanceAmount.textContent = formattedBalance;
                }
            }

            // Вызываем при инициализации
            updateBalanceDisplay();
            
            // Initialize the app
            init();

            // Initialize progress bar visibility setting
            const showProgressBarToggle = document.getElementById('showProgressBarToggle');
            if (showProgressBarToggle) {
                // Set initial state
                if (uiSettings.showProgressBar) {
                    showProgressBarToggle.classList.add('on');
                } else {
                    showProgressBarToggle.classList.remove('on');
                }
                updateProgressBarVisibility();

                showProgressBarToggle.addEventListener('click', function() {
                    const isOn = showProgressBarToggle.classList.contains('on');
                    if (isOn) {
                        showProgressBarToggle.classList.remove('on');
                        uiSettings.showProgressBar = false;
                    } else {
                        showProgressBarToggle.classList.add('on');
                        uiSettings.showProgressBar = true;
                    }
                    saveUISettings();
                    updateProgressBarVisibility();
                });
            }

            // Вызываем при инициализации
            updateBalanceDisplay();

            // Initialize theme buttons
            const lightThemeBtn = document.getElementById('lightThemeBtn');
            const darkThemeBtn = document.getElementById('darkThemeBtn');
            console.log('Theme buttons found:', { lightThemeBtn, darkThemeBtn });
            if (lightThemeBtn) {
                lightThemeBtn.addEventListener('click', () => {
                    console.log('Light Theme button clicked');
                    switchTheme('light');
                });
            }
            if (darkThemeBtn) {
                darkThemeBtn.addEventListener('click', () => {
                    console.log('Dark Theme button clicked');
                    switchTheme('dark');
                });
            }

            // Добавляем логи для отладки переноса слов в заголовках таблицы
            function logTableHeaderStyles() {
                const thElements = document.querySelectorAll('th');
                console.log('Стили заголовков таблицы для переноса слов:');
                thElements.forEach((th, index) => {
                    const computedStyle = getComputedStyle(th);
                    console.log(`TH ${index} (${th.textContent.trim()}):`);
                    console.log(`  white-space: ${computedStyle.whiteSpace}`);
                    console.log(`  word-break: ${computedStyle.wordBreak}`);
                    console.log(`  hyphens: ${computedStyle.hyphens}`);
                    console.log(`  width: ${computedStyle.width}`);
                    console.log(`  min-width: ${computedStyle.minWidth}`);
                    console.log(`  padding: ${computedStyle.padding}`);
                    console.log(`  text-align: ${computedStyle.textAlign}`);
                    console.log(`  line-height: ${computedStyle.lineHeight}`);
                    console.log(`  overflow: ${computedStyle.overflow}`);
                    console.log(`  text-overflow: ${computedStyle.textOverflow}`);
                    console.log(`  font-size: ${computedStyle.fontSize}`);
                });
            }

            // Логируем стили после инициализации
            setTimeout(logTableHeaderStyles, 1500);

            // Добавляем логи для проверки примененных стилей к th
            setTimeout(() => {
                console.log('Проверка примененных стилей к th элементам после обновлений:');
                const thElements = document.querySelectorAll('th');
                thElements.forEach((th, index) => {
                    const computedStyle = getComputedStyle(th);
                    console.log(`TH ${index} (${th.textContent.trim()}):`);
                    console.log(`  white-space: ${computedStyle.whiteSpace}`);
                    console.log(`  word-break: ${computedStyle.wordBreak}`);
                    console.log(`  font-size: ${computedStyle.fontSize}`);
                    console.log(`  padding: ${computedStyle.padding}`);
                    console.log(`  min-width: ${computedStyle.minWidth}`);
                    console.log(`  line-height: ${computedStyle.lineHeight}`);
                    console.log(`  overflow: ${computedStyle.overflow}`);
                    console.log(`  text-overflow: ${computedStyle.textOverflow}`);
                });
                console.log('Стили успешно применены: white-space: normal; word-break: keep-all; overflow: visible; для всех th.');
            }, 2000);

            // Добавляем логи для проверки примененных стилей к th
            setTimeout(() => {
                console.log('Applied styles to th: white-space: nowrap; word-break: keep-all;');
                const thElements = document.querySelectorAll('th');
                thElements.forEach((th, index) => {
                    const computedStyle = getComputedStyle(th);
                    console.log(`TH ${index} (${th.textContent}): white-space: ${computedStyle.whiteSpace}, word-break: ${computedStyle.wordBreak}`);
                });
            }, 1600);

            // Дополнительные логи для проверки изменений в стилях th
            setTimeout(() => {
                console.log('CSS changes applied to th elements: word-break: break-word; white-space: normal; font-size: 0.75rem; padding: 12px 10px; min-width: 100px;');
                const thElements = document.querySelectorAll('th');
                thElements.forEach((th, index) => {
                    const computedStyle = getComputedStyle(th);
                    console.log(`TH ${index} (${th.textContent}): font-size: ${computedStyle.fontSize}, word-break: ${computedStyle.wordBreak}, padding: ${computedStyle.padding}, white-space: ${computedStyle.whiteSpace}, min-width: ${computedStyle.minWidth}`);
                });
            }, 1600);

            // Add logging for balance alignment and styles
            function logBalanceAlignment() {
                const balanceItems = document.querySelectorAll('.balance-item');
                console.log('Balance alignment check:');
                balanceItems.forEach((item, index) => {
                    console.log(`Balance item ${index} (${item.querySelector('.balance-label').textContent}): width=${item.offsetWidth}, height=${item.offsetHeight}`);
                    const label = item.querySelector('.balance-label');
                    const value = item.querySelector('.balance-value');
                    console.log(`  Label: width=${label.offsetWidth}, height=${label.offsetHeight}`);
                    console.log(`  Value: width=${value.offsetWidth}, height=${value.offsetHeight}`);
                });
            }

            // Add logging for Starting Balance styles
            function logStartingBalanceStyles() {
                const startingBalance = document.getElementById('startingBalanceValue');
                if (startingBalance) {
                    const computedStyle = getComputedStyle(startingBalance);
                    console.log('Starting Balance computed styles:');
                    console.log('  background-color:', computedStyle.backgroundColor);
                    console.log('  color:', computedStyle.color);
                    console.log('  border:', computedStyle.border);
                    console.log('  border-radius:', computedStyle.borderRadius);
                    console.log('  padding:', computedStyle.padding);
                    console.log('  cursor:', computedStyle.cursor);
                    console.log('  box-shadow:', computedStyle.boxShadow);
                    console.log('  opacity:', computedStyle.opacity);
                    console.log('  transform:', computedStyle.transform);
                    console.log('  transition:', computedStyle.transition);
                    console.log('  classList:', startingBalance.classList.toString());
                    console.log('  Current theme:', document.documentElement.getAttribute('data-theme'));
                    console.log('  CSS variables:');
                    console.log('    --button-color:', getComputedStyle(document.documentElement).getPropertyValue('--button-color'));
                    console.log('    --button-text-color:', getComputedStyle(document.documentElement).getPropertyValue('--button-text-color'));
                    console.log('    --bg-color:', getComputedStyle(document.documentElement).getPropertyValue('--bg-color'));
                    console.log('    --text-color:', getComputedStyle(document.documentElement).getPropertyValue('--text-color'));
                } else {
                    console.log('Starting Balance element not found');
                }
            }

            // Add logging for Comment styles
            function logCommentStyles() {
                const monthCommentsTextarea = document.getElementById('monthCommentsInput');
                const commentsCells = document.querySelectorAll('.comments-cell');
                const currentTheme = document.documentElement.getAttribute('data-theme');
                console.log('Logging comment styles for theme:', currentTheme);
                console.log('  CSS variables:');
                console.log('    --text-color:', getComputedStyle(document.documentElement).getPropertyValue('--text-color'));
                console.log('    --bg-color:', getComputedStyle(document.documentElement).getPropertyValue('--bg-color'));
                if (monthCommentsTextarea) {
                    const computedStyle = getComputedStyle(monthCommentsTextarea);
                    console.log('Month Comments textarea styles:');
                    console.log('  color:', computedStyle.color);
                    console.log('  background-color:', computedStyle.backgroundColor);
                    console.log('  Applied styles confirmed: color set to var(--text-color) for visibility in dark theme.');
                } else {
                    console.log('Month Comments textarea not found');
                }
                commentsCells.forEach((cell, index) => {
                    const computedStyle = getComputedStyle(cell);
                    console.log(`Comments cell ${index} styles:`);
                    console.log('  color:', computedStyle.color);
                });
                console.log('Comment visibility updated for dark theme.');
            }

            // Log after init
            setTimeout(logBalanceAlignment, 1000);

            // Add theme toggle for testing
            document.addEventListener('keydown', function(e) {
                if (e.key === 't' || e.key === 'T') {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    if (currentTheme === 'dark') {
                        document.documentElement.removeAttribute('data-theme');
                        console.log('Switched to light theme');
                    } else {
                        document.documentElement.setAttribute('data-theme', 'dark');
                        console.log('Switched to dark theme');
                    }
                    setTimeout(logBalanceAlignment, 500);
                    setTimeout(logStartingBalanceStyles, 500);
                }
            });

            // ==================== EXPORT FUNCTIONALITY ====================

            // Elements for export
            let exportBtn = document.getElementById('exportBtn');
            const exportModal = document.getElementById('exportModal');
            const exportStartDate = document.getElementById('exportStartDate');
            const exportEndDate = document.getElementById('exportEndDate');
            const saveExportBtn = document.getElementById('saveExportBtn');
            const cancelExportBtn = document.getElementById('cancelExportBtn');
            const exportTabs = document.querySelectorAll('.export-tab');

            // State for export
            let currentExportType = 'table';
            let isExportInProgress = false;

            // Initialize export functionality
            function initExport() {
                console.log('initExport: Starting export initialization');

                // Set default dates (last 30 days)
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - 30);

                if (exportStartDate) exportStartDate.value = formatDateForInput(startDate);
                if (exportEndDate) exportEndDate.value = formatDateForInput(endDate);

                // Export tab handling
                if (exportTabs) {
                    exportTabs.forEach(tab => {
                        tab.addEventListener('click', () => {
                            exportTabs.forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                            currentExportType = tab.dataset.tab;
                        });
                    });
                }

                // Убедимся, что кнопка экспорта всегда работает
                if (exportBtn) {
                    // Гарантируем начальное состояние кнопки
                    exportBtn.disabled = false;
                    isExportInProgress = false;

                    // Добавляем обработчик клика (только один раз)
                    exportBtn.addEventListener('click', handleExportClick);
                    console.log('initExport: Export button initialized successfully');
                } else {
                    console.error('initExport: exportBtn not found');
                }
            }

            // Функция для безопасного управления состоянием кнопки экспорта
            function setExportButtonState(disabled, reason = '') {
                if (!exportBtn) {
                    console.error('setExportButtonState: exportBtn not found');
                    return;
                }

                const wasDisabled = exportBtn.disabled;
                exportBtn.disabled = disabled;
                isExportInProgress = disabled;

                console.log(`setExportButtonState: Button ${disabled ? 'disabled' : 'enabled'} (${reason})`);
                console.log(`setExportButtonState: Previous state: ${wasDisabled}, New state: ${disabled}`);
                console.log(`setExportButtonState: Current exportBtn reference:`, exportBtn);
            }

            // Обработчик клика по кнопке экспорта
            function handleExportClick() {
                console.log('handleExportClick: Export button clicked');

                // Проверяем состояние экспорта
                if (isExportInProgress) {
                    console.log('handleExportClick: Export already in progress, ignoring click');
                    return;
                }

                // Проверяем существование элементов
                if (!exportBtn) {
                    console.error('handleExportClick: exportBtn not found');
                    return;
                }

                if (!exportModal) {
                    console.error('handleExportClick: exportModal not found');
                    return;
                }

                console.log('handleExportClick: Opening export modal');

                // Открываем модальное окно
                exportModal.style.display = 'flex';

                // Сбрасываем даты при каждом открытии
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - 30);

                if (exportStartDate) exportStartDate.value = formatDateForInput(startDate);
                if (exportEndDate) exportEndDate.value = formatDateForInput(endDate);

                console.log('handleExportClick: Export modal opened successfully');
            }

            // Format date for input[type="date"]
            function formatDateForInput(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            // Parse date from input
            function parseExportDate(dateString) {
                const [year, month, day] = dateString.split('-').map(Number);
                return new Date(year, month - 1, day);
            }

            // Export data to Excel
            function exportToExcel() {
                console.log('exportToExcel: Starting export process');

                // Проверяем, что экспорт не выполняется
                if (isExportInProgress) {
                    console.log('exportToExcel: Export already in progress');
                    return;
                }

                try {
                    // Отключаем кнопку экспорта
                    setExportButtonState(true, 'starting export');

                    // Показываем уведомление о начале экспорта
                    showNotification('Starting export...', 'success');

                    const startDate = parseExportDate(exportStartDate.value);
                    const endDate = parseExportDate(exportEndDate.value);

                    if (startDate > endDate) {
                        showNotification('Start date cannot be after end date', 'error');
                        // Восстанавливаем состояние кнопки при ошибке валидации
                        setExportButtonState(false, 'validation error');
                        return;
                    }

                    let data;
                    let filename;

                    if (currentExportType === 'table') {
                        data = prepareTableDataForExport(startDate, endDate);
                        filename = `trading_diary_${formatDateForInput(startDate)}_to_${formatDateForInput(endDate)}.xlsx`;
                    } else {
                        data = prepareGeneralDataForExport(startDate, endDate);
                        filename = `trading_general_${formatDateForInput(startDate)}_to_${formatDateForInput(endDate)}.xlsx`;
                    }

                    // Проверяем, есть ли данные для экспорта
                    if (!data || data.length === 0) {
                        showNotification('No data found for the selected period', 'error');
                        setExportButtonState(false, 'no data');
                        return;
                    }

                    // Create workbook and worksheet
                    const wb = XLSX.utils.book_new();
                    const ws = XLSX.utils.json_to_sheet(data);

                    // Add worksheet to workbook
                    XLSX.utils.book_append_sheet(wb, ws, 'Trading Data');

                    // Записываем книгу в бинарный формат
                    const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'binary' });

                    // Создаем Blob из бинарных данных
                    const blob = new Blob([s2ab(wbout)], { type: 'application/octet-stream' });

                    // Создаем ссылку на скачивание
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);

                    // Пытаемся инициировать скачивание
                    try {
                        a.click();
                        console.log('exportToExcel: Download link clicked');

                        // Проверяем, поддерживается ли скачивание (для случаев блокировки браузером)
                        setTimeout(() => {
                            // Если браузер блокирует автоматическое скачивание, показываем инструкции
                            if (document.body.contains(a)) {
                                showNotification('Download blocked by browser. Please check your browser settings or try again.', 'error');
                            }
                        }, 1000);

                    } catch (downloadError) {
                        console.error('Download initiation error:', downloadError);
                        showNotification('Download failed. Please try again or check browser settings.', 'error');
                        throw downloadError; // Перебрасываем ошибку для обработки в catch
                    }

                    // Удаляем ссылку и освобождаем память
                    setTimeout(() => {
                        if (document.body.contains(a)) {
                            document.body.removeChild(a);
                        }
                        window.URL.revokeObjectURL(url);
                    }, 100);

                    // Close modal after successful export
                    closeModal();

                    // Show success notification
                    showNotification('Excel file downloaded successfully', 'success');
                    console.log('exportToExcel: Export completed successfully');

                } catch (error) {
                    console.error('Export error:', error);
                    let errorMessage = 'Export error occurred';
                    if (error.name === 'SecurityError') {
                        errorMessage = 'Download blocked by browser security. Please allow downloads or try a different browser.';
                    } else if (error.message) {
                        errorMessage = `Export failed: ${error.message}`;
                    }
                    showNotification(errorMessage, 'error');
                } finally {
                    // ВСЕГДА восстанавливаем состояние кнопки экспорта
                    setExportButtonState(false, 'export finished');
                    console.log('exportToExcel: Finally block executed, button state restored');
                }
            }

            // Prepare table data for export
            function prepareTableDataForExport(startDate, endDate) {
                const exportData = [];

                // Get all dates in range
                const datesInRange = getDatesInRange(startDate, endDate);

                datesInRange.forEach(date => {
                    const dateKey = formatDateKey(date);
                    const dayData = historyData[dateKey];

                    if (dayData && dayData.trades) {
                        dayData.trades.forEach((trade, tradeIndex) => {
                            // Only export trades with data
                            if (trade.tradeAmount || trade.result || trade.emotion || trade.comment) {
                                const rowData = {
                                    'Date': formatDate(date),
                                    'Trade Number': tradeIndex + 1,
                                    'Trade Amount': trade.tradeAmount || 0,
                                    'Result Type': trade.result ? trade.result.type : '',
                                    'Result Amount': trade.result ? trade.result.amount : 0,
                                    'Emotional State': trade.emotion || '',
                                    'Comments': trade.comment || ''
                                };
                                exportData.push(rowData);
                            }
                        });
                    }
                });

                return exportData;
            }

            // Prepare general data for export
            function prepareGeneralDataForExport(startDate, endDate) {
                const exportData = [];

                // Get all dates in range
                const datesInRange = getDatesInRange(startDate, endDate);

                datesInRange.forEach(date => {
                    const dateKey = formatDateKey(date);
                    const dayData = historyData[dateKey];
                    const generalDayData = generalData[dateKey] || {};

                    // Calculate withdrawals for this date
                    const dayWithdrawals = withdrawalData[dateKey] || [];
                    const totalWithdrawal = dayWithdrawals.reduce((sum, withdrawal) => sum + withdrawal.amount, 0);

                    if (dayData && dayData.trades) {
                        // Calculate day totals
                        let dayProfit = 0;
                        let dayLoss = 0;
                        let winTrades = 0;
                        let lossTrades = 0;
                        let totalTrades = 0;

                        dayData.trades.forEach(trade => {
                            if (trade.result) {
                                totalTrades++;
                                if (trade.result.type === 'profit') {
                                    dayProfit += trade.result.amount;
                                    winTrades++;
                                } else if (trade.result.type === 'loss') {
                                    dayLoss += trade.result.amount;
                                    lossTrades++;
                                }
                            }
                        });

                        const netResult = dayProfit - dayLoss;
                        const rowData = {
                            'Date': formatDate(date),
                            'Profit Target (%)': generalDayData.profitTarget || '',
                            'Loss Target (%)': generalDayData.lossTarget || '',
                            'Actual P/L (%)': generalDayData.actualProfitLoss || 0,
                            'Total Profit': dayProfit,
                            'Total Loss': dayLoss,
                            'Net Result': netResult,
                            'Withdrawals': totalWithdrawal,
                            'Total (Net - Withdrawals)': netResult - totalWithdrawal, // Новая колонка
                            'Winning Trades': winTrades,
                            'Losing Trades': lossTrades,
                            'Total Trades': totalTrades,
                            'Win Rate (%)': totalTrades > 0 ? ((winTrades / totalTrades) * 100).toFixed(2) : 0
                        };

                        exportData.push(rowData);
                    } else if (totalWithdrawal > 0) {
                        // Если нет торгов, но есть выводы - все равно экспортируем
                        const rowData = {
                            'Date': formatDate(date),
                            'Profit Target (%)': generalDayData.profitTarget || '',
                            'Loss Target (%)': generalDayData.lossTarget || '',
                            'Actual P/L (%)': generalDayData.actualProfitLoss || 0,
                            'Total Profit': 0,
                            'Total Loss': 0,
                            'Net Result': 0,
                            'Withdrawals': totalWithdrawal,
                            'Total (Net - Withdrawals)': -totalWithdrawal,
                            'Winning Trades': 0,
                            'Losing Trades': 0,
                            'Total Trades': 0,
                            'Win Rate (%)': 0
                        };
                        exportData.push(rowData);
                    }
                });

                return exportData;
            }

            // Get all dates in a range
            function getDatesInRange(startDate, endDate) {
                const dates = [];
                const currentDate = new Date(startDate);

                while (currentDate <= endDate) {
                    dates.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                return dates;
            }

            // Event listeners for export
            if (saveExportBtn) {
                saveExportBtn.addEventListener('click', () => {
                    console.log('saveExportBtn: clicked');
                    if (!isExportInProgress) {
                        exportToExcel();
                    } else {
                        console.log('saveExportBtn: Export already in progress');
                    }
                });
            }

            if (cancelExportBtn) {
                cancelExportBtn.addEventListener('click', () => {
                    console.log('cancelExportBtn: clicked');
                    closeModal();
                });
            }

            if (exportModal) {
                exportModal.addEventListener('click', (e) => {
                    if (e.target === exportModal) {
                        console.log('exportModal: clicked outside');
                        closeModal();
                    }
                });
            }

            // Close export modal with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && exportModal && exportModal.style.display === 'flex') {
                    console.log('Escape key pressed in export modal');
                    closeModal();
                }
            });

            // Update closeModal function to include export modal
            function closeModal() {
                console.log('closeModal: Closing all modals');

                const modals = [
                    resultModal,
                    tradeAmountModal,
                    withdrawalModal,
                    withdrawalActionModal,
                    emotionModal,
                    commentsModal,
                    balanceModal,
                    targetModal,
                    exportModal  // Add export modal to the list
                ];

                modals.forEach(modal => {
                    if (modal) {
                        modal.style.display = 'none';
                    }
                });

                // Reset state variables
                currentCell = null;
                currentTradeIndex = null;
                currentColumnType = null;
                currentTargetDay = null;
                currentTargetType = null;
                currentWithdrawalDate = null;
                currentWithdrawalIndex = null;

                // Reset input fields
                if (amountInput) amountInput.value = '';
                if (tradeAmountInput) tradeAmountInput.value = '';
                if (withdrawalAmountInput) withdrawalAmountInput.value = '';
                if (balanceInput) balanceInput.value = '';
                if (targetInput) targetInput.value = '';
                if (commentsInput) commentsInput.value = '';

                // Гарантированное восстановление состояния кнопки экспорта при закрытии любого модального окна
                setExportButtonState(false, 'modal closed');
            }

            // Initialize export when app starts
            initExport();

            // Add browser export option to modal
            addBrowserExportOption();

            // Check URL parameters for automatic export
            checkUrlParameters();

            // Function to add browser export button to modal
            function addBrowserExportOption() {
                const browserBtn = document.getElementById('browserExportBtn');
                if (browserBtn) {
                    browserBtn.addEventListener('click', openInExternalBrowser);
                }
            }

            // Function to open export in external browser
            function openInExternalBrowser() {
                // Get current export dates
                const startDate = parseExportDate(exportStartDate.value);
                const endDate = parseExportDate(exportEndDate.value);

                // Create URL with parameters for the app
                const appUrl = window.location.href.split('?')[0];
                const exportUrl = `${appUrl}?export=true&start=${formatDateForInput(startDate)}&end=${formatDateForInput(endDate)}&type=${currentExportType}`;

                // Open in browser
                if (tg && tg.openLink) {
                    tg.openLink(exportUrl);
                } else {
                    window.open(exportUrl, '_blank');
                }

                showNotification('Opening in browser for better download support', 'success');
                closeModal();

                // Automatically trigger export after opening in browser
                setTimeout(() => {
                    if (window.location.search.includes('export=true')) {
                        exportToExcel();
                    }
                }, 2000);
            }

            // Function to check URL parameters for automatic export
            function checkUrlParameters() {
                const urlParams = new URLSearchParams(window.location.search);
                const exportParam = urlParams.get('export');
                const startParam = urlParams.get('start');
                const endParam = urlParams.get('end');
                const typeParam = urlParams.get('type');

                if (exportParam === 'true' && startParam && endParam) {
                    // Set export parameters
                    if (exportStartDate) exportStartDate.value = startParam;
                    if (exportEndDate) exportEndDate.value = endParam;
                    if (typeParam) currentExportType = typeParam;

                    // Automatically start export
                    setTimeout(() => {
                        exportToExcel();
                    }, 1000); // Small delay to ensure everything is loaded
                }
            }

            // Debug function for Telegram
            function checkTelegramEnvironment() {
                const isTelegram = window.Telegram && Telegram.WebApp;
                const platform = isTelegram ? Telegram.WebApp.platform : 'browser';

                console.log('Environment check:', {
                    isTelegram: isTelegram,
                    platform: platform,
                    userAgent: navigator.userAgent,
                    exportSupported: typeof XLSX !== 'undefined'
                });

                return isTelegram;
            }

            // Call this on startup
            setTimeout(checkTelegramEnvironment, 500);
            checkUrlParameters();
        });
    </script>
</body>
</html>
