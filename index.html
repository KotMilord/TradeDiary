<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Diary</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
         /* CSS Variables for Light and Dark Themes */
         :root {
             --bg-color: #ffffff;
             --text-color: #252525;
             --secondary-bg: rgba(235, 232, 232, 0.95);
             --hint-color: rgba(0, 0, 0, 0.3);
             --button-color: #3498dbb4;
             --button-text-color: #dddddd;
             --border-color: #e0e0e0;
             --shadow-color: rgba(0, 0, 0, 0.8);
             --positive-color: #2ecc71;
             --negative-color: #e74c3c;
             --refund-color: #3498db;
             --profit-bg: #e8f5e9;
             --loss-bg: #ffebee;
             --refund-bg: #e3f2fd;
             --cell-bg: #fafafa;
             --cell-hover-bg: #e3f2fd;
             --modal-bg: #ffffff;
             --input-bg: #ffffff;
             --input-border: #ddd;
             --progress-bg: #e0e0e0;
             --progress-profit: #4CAF50;
             --progress-loss: #F44336;
             --tab-bg: #ecf0f1;
             --tab-active-bg: #3498dbb4;
             --notification-success: #27ae60;
             --notification-error: #e74c3c;
         }

         [data-theme="dark"] {
             --bg-color: #242424;
             --text-color: #dddddd;
             --secondary-bg: #2d2d2d;
             --hint-color: rgba(255, 255, 255, 0.3);
             --button-color: #3498dbb4;
             --button-text-color: #dddddd;
             --border-color: #444444;
             --shadow-color: rgba(0, 0, 0, 0.8);
             --positive-color: #4CAF50;
             --negative-color: #F44336;
             --refund-color: #2196F3;
             --profit-bg: #1b2e1b;
             --loss-bg: #2e1b1b;
             --refund-bg: #1b1e2e;
             --cell-bg: #2d2d2d;
             --cell-hover-bg: #3d3d3d;
             --modal-bg: #2d2d2d;
             --input-bg: #3d3d3d;
             --input-border: #555555;
             --progress-bg: #444444;
             --progress-profit: #4CAF50;
             --progress-loss: #F44336;
             --tab-bg: #2d2d2d;
             --tab-active-bg: #3498dbb4;
             --notification-success: #4CAF50;
             --notification-error: #F44336;
         }

         [data-theme="dark"] .balance-label,
         [data-theme="dark"] .progress-label,
         [data-theme="dark"] .setting-label {
             color: var(--text-color);
         }

         [data-theme="dark"] .settings-panel h3 {
             color: var(--text-color);
         }

         [data-theme="dark"] .progress-stats {
             color: var(--text-color);
         }
          [data-theme="dark"] .progress-bar {
              background: var(--progress-bg);
          }

          [data-theme="dark"] .progress-container {
              background: var(--secondary-bg);
              border: 1px solid var(--border-color);
          }


          [data-theme="dark"] .date-label {
              background: var(--secondary-bg);
              border: 1px solid var(--border-color);
              color: var(--text-color);
          }

          [data-theme="dark"] .month-comments textarea {
              background: var(--input-bg);
              color: var(--text-color);
              border: 1px solid var(--input-border);
          }

          [data-theme="dark"] .settings-panel {
              background: var(--secondary-bg);
              border: 1px solid var(--border-color);
          }




         * {
             box-sizing: border-box;
             margin: 0;
             padding: 0;
             font-family: 'Roboto', Arial, sans-serif;
         }
        
        body {
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 5px;
            font-size: 14px;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
            background: var(--secondary-bg);
            border-radius: 12px;
            box-shadow: 0 2px 12px var(--shadow-color);
            overflow: hidden;
            border: 1px solid var(--hint-color);
        }
        
        header {
            background: var(--bg-color);
            color: var(--text-color);
            padding: 10px;
            text-align: center;
            position: relative;
        }
        
        .date-display {
            font-size: 1rem;
            margin-bottom: 5px;
        }
        
        .btn {
            background: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
            margin: 2px;
        }
        
        .btn:hover {
            opacity: 0.9;
        }
        
        .btn-success {
            background: var(--button-color);
        }
        
        .btn-danger {
            background: var(--button-color);
        }
        
        .btn-warning {
            background: var(--button-color);
        }
        
        .main-content {
            padding: 10px;
        }
        
        .balance-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            margin-bottom: 15px;
            background: var(--bg-color);
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--hint-color);
            gap: 8px;
            box-shadow: inset 0 1px 3px var(--shadow-color);
        }
        
        .balance-item {
            text-align: center;
            background: var(--secondary-bg);
            border-radius: 8px;
            padding: 8px 4px;
            border: 1px solid var(--hint-color);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }

        .balance-label {
            font-size: 0.7rem;
            color: var(--shadow-color);
            line-height: 1.2;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 1.5rem;
            min-height: 1.5rem;
            margin-bottom: 0;
        }

        .balance-value {
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            line-height: 1.2;
            transition: all 0.2s;
            color: var(--text-color);
            word-break: break-all;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 2rem;
            min-height: 2rem;
        }
        
        .starting-balance {
            background-color: var(--button-color);
            border-radius: 8px;
            padding: 6px 8px;
            border: 2px solid var(--button-color);
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            opacity: 0.7;
        }

        .starting-balance:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.8);
        }

        .starting-balance.balance-value {
            color: #007bff !important;
            border: 2px solid #007bff;
            background: rgba(0, 123, 255, 0.15);
            opacity: 0.7;
            border-radius: 6px;
            padding: 4px 6px;
            font-size: 1.2rem;
            font-weight: 700;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        /* Обновляем hover для .starting-balance.balance-value */
        .starting-balance.balance-value:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .positive {
            color: var(--positive-color);
        }

        .negative {
            color: var(--negative-color);
        }
        
        .table-container {
            overflow-x: auto;
            margin-bottom: 10px;
            border: 1px solid var(--hint-color);
            border-radius: 10px;
            width: 100%;
            box-shadow: 0 1px 3px var(--shadow-color);
        }
        
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: var(--bg-color);
            font-size: 0.8rem;
            table-layout: fixed;
            color: var(--text-color);
            border-radius: 10px;
            overflow: hidden;
        }
        
        th, td {
            border-bottom: 1px solid var(--hint-color);
            border-right: 1px solid var(--hint-color);
            padding: 8px;
            text-align: center;
            min-width: 60px;
            height: 40px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-color);
        }
        
        th {
            background: var(--button-color);
            color: var(--button-text-color);
            position: sticky;
            top: 0;
            font-weight: 600;
            white-space: normal;
            word-break: keep-all;
            line-height: 1.3;
            padding: 12px 10px;
            text-align: center;
            font-size: 0.8rem;
            min-width: 120px;
            overflow: visible;
            text-overflow: clip;
        }

        
        th:last-child, td:last-child {
            border-right: none;
        }
        
        tr:last-child td {
            border-bottom: none;
        }
        
        .trade-header {
            background: var(--bg-color);
            color: var(--text-color);
            width: 50px;
        }
        
        .cell {
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            background-color: var(--cell-bg);
        }

        .cell:hover {
            background-color: var(--cell-hover-bg);
        }
        
        .cell.disabled {
            opacity: 0.6;
            cursor: not-allowed !important;
            pointer-events: none;
        }
        
        .cell-content {
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .profit {
            background: var(--profit-bg) !important;
            color: var(--positive-color) !important;
        }

        .loss {
            background: var(--loss-bg) !important;
            color: var(--negative-color) !important;
        }

        .refund {
            background: var(--refund-bg) !important;
            color: var(--refund-color) !important;
        }
        
        .emotion-cell {
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        .comments-cell {
            text-align: left;
            max-width: 140px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }


        .comments-cell {
            color: var(--text-color);
        }
        
        .add-trade-btn {
            margin-top: 12px;
            width: 100%;
            padding: 12px;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .add-trade-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Убраны кнопки действий */
        .telegram-actions {
            display: none;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--modal-bg);
            color: var(--text-color);
            padding: 15px;
            border-radius: 8px;
            width: 90%;
            max-width: 300px;
            text-align: center;
        }

        [data-theme="dark"] .modal-content {
            background: var(--modal-bg);
            color: var(--text-color);
        }

        [data-theme="dark"] .emotion-option {
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }

        [data-theme="dark"] .emotion-option:hover {
            background: var(--input-bg);
        }

        [data-theme="dark"] .emotion-label {
            color: var(--text-color);
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .modal-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            flex: 1;
            min-width: 80px;
        }
        
        .profit-btn {
            background: var(--positive-color);
            color: var(--button-text-color);
        }
        
        .loss-btn {
            background: var(--negative-color);
            color: var(--button-text-color);
        }
        
        .refund-btn {
            background: var(--refund-color);
            color: var(--button-text-color);
        }
        
        .reset-btn {
            background: var(--hint-color);
            color: var(--button-text-color);
        }
        
        .emotion-modal-content {
            max-width: 250px;
        }
        
        .emotion-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .emotion-option {
            padding: 8px;
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            color: var(--text-color);
        }
        
        .emotion-option:hover {
            background: var(--secondary-bg);
        }
        
        .emotion-emoji {
            font-size: 1.5rem;
            margin-bottom: 3px;
            color: var(--text-color);
        }
        
        .emotion-label {
            font-size: 0.7rem;
        }
        
        .comments-modal-content {
            max-width: 300px;
        }
        
        .comments-textarea {
            width: 100%;
            min-height: 100px;
            padding: 8px;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
            font-size: 0.8rem;
            margin-top: 10px;
        }

        [data-theme="dark"] .comments-textarea {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }
        
        .comments-textarea::placeholder {
            color: var(--hint-color);
        }
        
        .tabs {
            display: flex;
            margin-bottom: 12px;
            background: var(--tab-bg);
            border-radius: 12px;
            overflow: hidden;
            flex-wrap: wrap;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .tab {
            flex: 1;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            min-width: 70px;
            color: var(--text-color);
            background: var(--tab-bg);
            font-weight: 500;
        }

        .tab.active {
            background: var(--tab-active-bg);
            color: var(--button-text-color);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .amount-input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .amount-input::placeholder {
            color: var(--hint-color);
        }
        
        .date-navigation {
            display: flex;
            justify-content: center;
            margin: 10px 0;
            gap: 10px;
            padding: 0 10px;
        }
        
        .date-btn {
            background: var(--button-color);
            color: var(--button-text-color);
            border: none;
            padding: 10px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: 0 2px 4px var(--shadow-color);
        }
        
        .date-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .date-label {
            padding: 10px 16px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 150px;
            text-align: center;
            font-weight: bold;
            background: var(--secondary-bg);
            border-radius: 20px;
            border: 1px solid var(--hint-color);
        }

        
        .notification {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px;
            border-radius: 4px;
            color: white;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
        }
        
        .notification.success {
            background: var(--notification-success);
            opacity: 1;
        }

        .notification.error {
            background: var(--notification-error);
            opacity: 1;
        }
        
        /* Styles for General tab */
        .general-header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .month-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .current-date {
            font-size: 0.9rem;
            color: var(--hint-color);
        }
        
        .general-table-container {
            overflow-x: auto;
            margin-bottom: 10px;
            border: 1px solid var(--hint-color);
            border-radius: 6px;
        }
        
        .general-table {
            font-size: 0.7rem;
        }
        
        .general-table th, .general-table td {
            padding: 6px;
            text-align: center;
            min-width: 80px;
            height: 30px;
        }

        .general-table th {
            white-space: normal;
            word-break: keep-all;
            overflow: visible;
            text-overflow: clip;
            font-size: 0.8rem;
        }
        
        .general-table .editable {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .general-table .editable:hover {
            background-color: var(--secondary-bg);
        }
        
        .general-table .current-day {
            background: rgba(52, 152, 219, 0.2);
            color: var(--button-text-color) !important;
            font-weight: bold;
            border: 1px solid rgba(52, 152, 219, 0.5);
        }

        [data-theme="dark"] .general-table .current-day {
            box-shadow: 0 0 3px rgba(52, 152, 219, 0.5);
        }
        
        .withdrawal-table-container {
            margin-top: 15px;
            overflow-x: auto;
            border: 1px solid var(--hint-color);
            border-radius: 6px;
        }
        
        .withdrawal-table {
            font-size: 0.7rem;
            width: 100%;
        }
        
        .withdrawal-table th, .withdrawal-table td {
            padding: 6px;
            text-align: center;
            min-width: 90px;
            height: 30px;
        }

        .withdrawal-table th {
            white-space: normal;
            word-break: keep-all;
            overflow: visible;
            text-overflow: clip;
            font-size: 0.8rem;
        }
        
        .withdrawal-table .editable {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .withdrawal-table .editable:hover {
            background-color: var(--secondary-bg);
        }
        
        .add-withdrawal-btn {
            margin-top: 10px;
            width: 100%;
        }
        
        .month-comments {
            margin-top: 15px;
        }
        
        .month-comments textarea {
            width: 100%;
            min-height: 80px;
            padding: 8px;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
            font-size: 0.8rem;
        }

        
        .month-comments textarea::placeholder {
            color: var(--hint-color);
        }
        
        .target-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .target-modal-content {
            background: var(--modal-bg);
            color: var(--text-color);
            padding: 15px;
            border-radius: 8px;
            width: 90%;
            max-width: 280px;
            text-align: center;
        }

        [data-theme="dark"] .target-modal-content {
            background: var(--modal-bg);
            color: var(--text-color);
        }
        
        .target-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .target-modal-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        .target-input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            font-size: 0.9rem;
        }

        [data-theme="dark"] .target-input {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }
        
        .target-input::placeholder {
            color: var(--hint-color);
        }
        
        .balance-input {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--hint-color);
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        [data-theme="dark"] .balance-input {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--input-border);
        }
        
        .balance-input::placeholder {
            color: var(--hint-color);
        }
        
        .withdrawal-action-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .withdrawal-action-content {
            background: var(--modal-bg);
            color: var(--text-color);
            padding: 15px;
            border-radius: 8px;
            width: 90%;
            max-width: 250px;
            text-align: center;
        }

        [data-theme="dark"] .withdrawal-action-content {
            background: var(--modal-bg);
            color: var(--text-color);
        }
        
        .withdrawal-action-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .withdrawal-action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            flex: 1;
        }
        
        .edit-btn {
            background: var(--button-color);
            color: var(--button-text-color);
        }
        
        .delete-btn {
            background: var(--negative-color);
            color: var(--button-text-color);
        }
        
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .history-table th, .history-table td {
            border: 1px solid var(--hint-color);
            padding: 10px;
            text-align: center;
            min-width: 100px;
        }

        .history-table th {
            white-space: normal;
            word-break: keep-all;
            overflow: visible;
            text-overflow: clip;
            font-size: 0.9rem;
        }
        
        .history-table th {
            background: var(--secondary-bg);
            color: var(--text-color);
        }
        
        .progress-container {
            margin-top: 15px;
            padding: 12px;
            background: var(--secondary-bg);
            border-radius: 12px;
            border: 1px solid var(--hint-color);
            box-shadow: inset 0 1px 3px var(--shadow-color);
        }


        .progress-label {
            font-size: 0.85rem;
            margin-bottom: 8px;
            color: var(--text-color);
            text-align: center;
            font-weight: 600;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--progress-bg);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 1px 3px var(--shadow-color);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--progress-profit), var(--progress-profit));
            border-radius: 6px;
            transition: width 0.5s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, var(--hint-color), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.75rem;
            color: var(--shadow-color);
            font-weight: 500;
        }
        
        .progress-loss-fill {
            background: var(--progress-loss) !important;
        }
        
        .center-marker {
            position: absolute;
            left: 50%;
            top: 0;
            height: 100%;
            width: 2px;
            background: var(--text-color);
            transform: translateX(-50%);
            z-index: 2;
        }
        
        /* Добавленные стили для кнопок настроек */
        .settings-btn {
            margin: 5px 0;
            width: 100%;
        }

        .settings-panel {
            margin-bottom: 20px;
            padding: 15px;
            background: var(--secondary-bg);
            border-radius: 8px;
            border: 1px solid var(--hint-color);
        }


        .settings-panel h3 {
            margin-bottom: 10px;
            color: var(--text-color);
        }
        
        .setting-row {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .setting-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-color);
        }
        
        .setting-label input[type="checkbox"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            .balance-container {
                flex-direction: row;
                gap: 5px;
                padding: 6px;
            }
            
            .balance-value {
                font-size: 1.1rem;
            }
        }
        
        /* Background coloring for cells based on amounts */
        .amount-positive {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(139, 195, 74, 0.1)) !important;
        }

        .amount-negative {
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.1), rgba(211, 47, 47, 0.1)) !important;
        }

        .amount-zero {
            background: linear-gradient(135deg, rgba(158, 158, 158, 0.1), rgba(189, 189, 189, 0.1)) !important;
        }

        @media (max-width: 360px) {
            table th, table td {
                min-width: 45px;
                padding: 3px;
                font-size: 0.65rem;
            }

            .tab {
                min-width: 60px;
                padding: 6px;
            }

            .trade-header {
                width: 40px;
            }

            .balance-item {
                min-width: 85px;
                margin: 0 1px;
            }

            .balance-label {
                font-size: 0.7rem;
            }

            .balance-value {
                   font-size: 1rem;
               }
           }
   
           /* Styles for Light and Dark Theme buttons */
           #lightThemeBtn {
               background: #333;
               color: #fff;
               border: 2px solid #333;
               border-radius: 6px;
               padding: 4px 6px;
               font-weight: 600;
               transition: all 0.3s ease;
               box-shadow: 0 2px 4px var(--shadow-color);
               cursor: pointer;
           }

           #lightThemeBtn:hover {
               opacity: 0.9;
               transform: translateY(-2px);
               box-shadow: 0 4px 8px var(--shadow-color);
           }

           #darkThemeBtn {
               background: #333;
               color: #fff;
               border: 2px solid #333;
               border-radius: 6px;
               padding: 4px 6px;
               font-weight: 600;
               transition: all 0.3s ease;
               box-shadow: 0 2px 4px var(--shadow-color);
               cursor: pointer;
           }

           #darkThemeBtn:hover {
               opacity: 0.9;
               transform: translateY(-2px);
               box-shadow: 0 4px 8px var(--shadow-color);
           }
   
           /* Ensure cohesive style for Clear buttons */
           .btn-warning {
               background: #ff9800;
               color: #fff;
               border: 2px solid #ff9800;
               border-radius: 6px;
               padding: 4px 6px;
               font-weight: 600;
               transition: all 0.3s ease;
               box-shadow: 0 2px 4px var(--shadow-color);
               cursor: pointer;
           }

           .btn-warning:hover {
               opacity: 0.9;
               transform: translateY(-2px);
               box-shadow: 0 4px 8px var(--shadow-color);
           }

           .btn-danger {
               background: #f44336;
               color: #fff;
               border: 2px solid #f44336;
               border-radius: 6px;
               padding: 4px 6px;
               font-weight: 600;
               transition: all 0.3s ease;
               box-shadow: 0 2px 4px var(--shadow-color);
               cursor: pointer;
           }

           .btn-danger:hover {
               opacity: 0.9;
               transform: translateY(-2px);
               box-shadow: 0 4px 8px var(--shadow-color);
           }

           /* Custom styles for settings buttons */
           #clearCurrentDayBtn {
               color: #d19e1c !important;
               border: 2px solid #d19e1c !important;
               background: #e7e7a1 !important;
               opacity: 0.7;
           }

           #clearCurrentDayBtn:hover {
               opacity: 0.9;
               transform: translateY(-2px);
               box-shadow: 0 4px 8px var(--shadow-color);
           }

           #clearAllDataBtn {
               color: #B22222 !important;
               border: 2px solid #B22222 !important;
               background: #ff7777 !important;
               opacity: 0.7;
           }

           #clearAllDataBtn:hover {
               opacity: 0.9;
               transform: translateY(-2px);
               box-shadow: 0 4px 8px var(--shadow-color);
           }

           #lightThemeBtn {
               color: #f5f5f5 !important;
               border: 2px solid #ffffff !important;
               background: #c4c4c4 !important;
               opacity: 0.7;
           }

           #lightThemeBtn:hover {
               opacity: 0.9;
               transform: translateY(-2px);
               box-shadow: 0 4px 8px var(--shadow-color);
           }

           #darkThemeBtn {
               color: #202020 !important;
               border: 2px solid #202020 !important;
               background: #5e5e5e !important;
               opacity: 0.7;
           }

           #darkThemeBtn:hover {
               opacity: 0.9;
               transform: translateY(-2px);
               box-shadow: 0 4px 8px var(--shadow-color);
           }

           #startingBalanceValue {
               background-color: #0091ca5e !important; /*  blue background */
           }
       </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Trading Diary</h1>
            <div class="date-display" id="currentDate"></div>
        </header>
        
        <div class="tabs">
            <div class="tab active" data-tab="table">Table</div>
            <div class="tab" data-tab="general">General</div>
            <div class="tab" data-tab="history">History</div>
            <div class="tab" data-tab="settings">Settings</div>
        </div>
        
        <div class="main-content">
            <div class="tab-content active" id="table-tab">
                <div class="balance-container">
                    <div class="balance-item">
                        <div class="balance-label">Starting Balance</div>
                        <div class="balance-value starting-balance" id="startingBalanceValue">10000</div>
                    </div>
                    <div class="balance-item">
                        <div class="balance-label">Current Balance</div>
                        <div class="balance-value" id="currentBalanceValue">10000</div>
                    </div>
                    <div class="balance-item">
                        <div class="balance-label">Day Result</div>
                        <div class="balance-value" id="dayResultValue">0</div>
                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-label">Daily Progress</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 50%"></div>
                    </div>
                    <div class="progress-stats">
                        <span id="progressStart">-2%</span>
                        <span id="progressCurrent">0%</span>
                        <span id="progressTarget">+2%</span>
                    </div>
                </div>
                
                <div class="date-navigation">
                    <button class="date-btn" id="prevDayBtn" aria-label="Previous day">←</button>
                    <div class="date-label" id="currentDayLabel">Today</div>
                    <button class="date-btn" id="nextDayBtn" disabled aria-label="Next day">→</button>
                </div>
                
                <div class="table-container">
                    <table id="tradingTable">
                        <thead>
                            <tr>
                                <th class="trade-header">Trade</th>
                                <th>Trade Amount</th>
                                <th>Profit/Loss Refund</th>
                                <th>Emotional State</th>
                                <th>Comments</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Table rows will be generated here -->
                        </tbody>
                    </table>
                </div>
                
                <button class="btn add-trade-btn" id="addTradeBtn" aria-label="Add new trade">+ Add Trade</button>
            </div>
            
            <!-- General Tab -->
            <div class="tab-content" id="general-tab">
                <div class="general-header">
                    <div class="current-date" id="currentGeneralDate"></div>
                </div>
                
                <div class="date-navigation">
                    <button class="date-btn" id="prevMonthBtn">←</button>
                    <div class="date-label" id="currentMonthLabel">Month Year</div>
                    <button class="date-btn" id="nextMonthBtn" disabled>→</button>
                </div>
                
                <div class="general-table-container">
                    <table class="general-table" id="generalTable">
                        <thead>
                            <tr>
                                <th>Day</th>
                                <th>Profit Target</th>
                                <th>Loss Target</th>
                                <th>Actual P/L</th>
                                <th>Winning Trades</th>
                                <th>Losing Trades</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Table rows will be generated here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="withdrawal-table-container">
                    <table class="withdrawal-table" id="withdrawalTable">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Withdrawal</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Withdrawal rows will be generated here -->
                        </tbody>
                    </table>
                </div>
                
                <button class="btn add-withdrawal-btn" id="addWithdrawalBtn">+ Add Withdrawal</button>
                
                <div class="month-comments">
                    <h3>Month Comments</h3>
                    <textarea id="monthCommentsInput" placeholder="Enter comments for the current month..."></textarea>
                </div>
            </div>
            
            <div class="tab-content" id="history-tab">
                <h2>Trading Days History</h2>
                <div class="table-container">
                    <table class="history-table" id="historyTable">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Total</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- History rows will be generated here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="tab-content" id="settings-tab">
                <h2>Application Settings</h2>
                
                <div class="settings-panel">
                    <h3>Data Management</h3>
                    <button class="btn btn-warning settings-btn" id="clearCurrentDayBtn">Clear Current Day</button>
                    <button class="btn btn-danger settings-btn" id="clearAllDataBtn">Delete all history</button>
                </div>
                
                <div class="settings-panel">
                    <h3>Display Settings</h3>
                    <div class="setting-row">
                        <label class="setting-label">
                            <input type="checkbox" id="showProgressBar" checked>
                            Show Daily Progress Bar
                        </label>
                    </div>
                    <div class="setting-row">
                        <button class="btn settings-btn" id="lightThemeBtn">Daylight</button>
                        <button class="btn settings-btn" id="darkThemeBtn">Midnight</button>
                    </div>
                </div>

                <div class="settings-panel">
                    <h3>About</h3>
                    <p>Trading Diary PRO v2.0</p>
                    <p>Developed for convenient tracking of trading results</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal for trade result -->
    <div class="modal" id="resultModal" role="dialog" aria-labelledby="resultModalTitle" aria-hidden="true">
        <div class="modal-content">
            <h2 class="modal-title" id="resultModalTitle">Select Trade Result</h2>
            <input type="text" class="amount-input" id="amountInput" placeholder="Enter amount" pattern="^[0-9]+([,.][0-9]+)*$" inputmode="decimal">
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" data-value="profit">Profit</button>
                <button class="modal-btn loss-btn" data-value="loss">Loss</button>
                <button class="modal-btn refund-btn" data-value="refund">Refund</button>
                <button class="modal-btn reset-btn" data-value="reset">Reset</button>
            </div>
        </div>
    </div>

    <!-- Modal for trade amount -->
    <div class="modal" id="tradeAmountModal">
        <div class="modal-content">
            <h2 class="modal-title">Enter Trade Amount</h2>
            <input type="text" class="amount-input" id="tradeAmountInput" placeholder="Enter amount" pattern="^[0-9]+([,.][0-9]+)*$" inputmode="decimal">
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveTradeAmountBtn">Save</button>
                <button class="modal-btn reset-btn" id="cancelTradeAmountBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for withdrawal -->
    <div class="modal" id="withdrawalModal">
        <div class="modal-content">
            <h2 class="modal-title">Enter Withdrawal Amount</h2>
            <input type="number" class="amount-input" id="withdrawalAmountInput" placeholder="Enter amount" step="0.01">
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveWithdrawalBtn">Save</button>
                <button class="modal-btn reset-btn" id="cancelWithdrawalBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for withdrawal actions -->
    <div class="withdrawal-action-modal" id="withdrawalActionModal">
        <div class="withdrawal-action-content">
            <h2 class="modal-title">Withdrawal Action</h2>
            <div class="withdrawal-action-buttons">
                <button class="withdrawal-action-btn edit-btn" id="editWithdrawalBtn">Edit</button>
                <button class="withdrawal-action-btn delete-btn" id="deleteWithdrawalBtn">Delete</button>
                <button class="withdrawal-action-btn reset-btn" id="cancelWithdrawalActionBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for emotions -->
    <div class="modal" id="emotionModal">
        <div class="modal-content emotion-modal-content">
            <h2 class="modal-title">Select Emotional State</h2>
            <div class="emotion-options">
                <div class="emotion-option" data-emotion="fear">
                    <div class="emotion-emoji">😨</div>
                    <div class="emotion-label">Fear</div>
                </div>
                <div class="emotion-option" data-emotion="greed">
                    <div class="emotion-emoji">🤑</div>
                    <div class="emotion-label">Greed</div>
                </div>
                <div class="emotion-option" data-emotion="joy">
                    <div class="emotion-emoji">😁</div>
                    <div class="emotion-label">Joy</div>
                </div>
                <div class="emotion-option" data-emotion="uncertainty">
                    <div class="emotion-emoji">😕</div>
                    <div class="emotion-label">Uncertainty</div>
                </div>
                <div class="emotion-option" data-emotion="neutral">
                    <div class="emotion-emoji">😐</div>
                    <div class="emotion-label">Neutral</div>
                </div>
                <div class="emotion-option" data-emotion="frustration">
                    <div class="emotion-emoji">😤</div>
                    <div class="emotion-label">Frustration</div>
                </div>
                <div class="emotion-option" data-emotion="contemplation">
                    <div class="emotion-emoji">🤔</div>
                    <div class="emotion-label">Contemplation</div>
                </div>
                <div class="emotion-option" data-emotion="boredom">
                    <div class="emotion-emoji">😴</div>
                    <div class="emotion-label">Boredom</div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn reset-btn" id="clearEmotionBtn">Clear</button>
            </div>
        </div>
    </div>

    <!-- Modal for comments -->
    <div class="modal" id="commentsModal">
        <div class="modal-content comments-modal-content">
            <h2 class="modal-title">Add Comment</h2>
            <textarea class="comments-textarea" id="commentsInput" placeholder="Enter comment..."></textarea>
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveCommentBtn">Save</button>
                <button class="modal-btn reset-btn" id="cancelCommentBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for setting balance -->
    <div class="modal" id="balanceModal">
        <div class="modal-content">
            <h2 class="modal-title">Set Starting Balance</h2>
            <input type="number" class="balance-input" id="balanceInput" placeholder="Enter balance" step="0.01">
            <div class="modal-buttons">
                <button class="modal-btn profit-btn" id="saveBalanceBtn">Save</button>
                <button class="modal-btn reset-btn" id="cancelBalanceBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal for setting targets -->
    <div class="target-modal" id="targetModal">
        <div class="target-modal-content">
            <h2 class="modal-title" id="targetModalTitle">Set Target (%)</h2>
            <input type="text" class="target-input" id="targetInput" placeholder="Enter value in %" pattern="^[0-9.,-]+$" inputmode="decimal">
            <div class="target-modal-buttons">
                <button class="target-modal-btn" id="applyToDayBtn">Day Only</button>
                <button class="target-modal-btn" id="applyToAllBtn">All Days</button>
                <button class="target-modal-btn" id="cancelTargetBtn">Cancel</button>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>
    
    <script>
        console.log('Trading Diary script loaded');
        // Initialize Telegram Web App
        let tg = window.Telegram?.WebApp;
        console.log('Telegram WebApp object:', tg);
        
        document.addEventListener('DOMContentLoaded', function() {
            // Theme management
            function updateTheme() {
                const savedTheme = localStorage.getItem('theme') || 'dark'; // Default to dark
                console.log('updateTheme called, savedTheme:', savedTheme);
                if (savedTheme === 'dark') {
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.removeAttribute('data-theme');
                }
                console.log('Applied theme: ' + savedTheme);
                console.log('data-theme attribute after updateTheme:', document.documentElement.getAttribute('data-theme'));
                setTimeout(logStartingBalanceStyles, 500);
                setTimeout(logCommentStyles, 500);
            }

            function switchTheme(theme) {
                console.log('switchTheme called with theme:', theme);
                if (theme === 'dark') {
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.removeAttribute('data-theme');
                }
                localStorage.setItem('theme', theme);
                console.log('Switched to ' + theme + ' theme');
                console.log('data-theme attribute set to:', document.documentElement.getAttribute('data-theme'));
                updateTheme();
                updateProgressBar(); // Обновляем прогресс-бар при переключении темы
                console.log('Progress bar updated after theme switch');
                // Обновляем стили для открытых модалей
                const openModals = document.querySelectorAll('.modal[style*="display: flex"], .target-modal[style*="display: flex"], .withdrawal-action-modal[style*="display: flex"]');
                openModals.forEach(modal => {
                    modal.style.background = getComputedStyle(document.documentElement).getPropertyValue('--modal-bg');
                    modal.style.color = getComputedStyle(document.documentElement).getPropertyValue('--text-color');
                });
            }

            // Initial theme setup
            updateTheme();

            // Expand the app to full screen
            if (tg && tg.expand) {
                tg.expand();
            }
            
            // Elements
            const currentDateEl = document.getElementById('currentDate');
            const tradingTable = document.getElementById('tradingTable');
            const resultModal = document.getElementById('resultModal');
            const tradeAmountModal = document.getElementById('tradeAmountModal');
            const withdrawalModal = document.getElementById('withdrawalModal');
            const withdrawalActionModal = document.getElementById('withdrawalActionModal');
            const emotionModal = document.getElementById('emotionModal');
            const commentsModal = document.getElementById('commentsModal');
            const balanceModal = document.getElementById('balanceModal');
            const historyTable = document.getElementById('historyTable');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const notification = document.getElementById('notification');
            const amountInput = document.getElementById('amountInput');
            const tradeAmountInput = document.getElementById('tradeAmountInput');
            const withdrawalAmountInput = document.getElementById('withdrawalAmountInput');
            const balanceInput = document.getElementById('balanceInput');
            const prevDayBtn = document.getElementById('prevDayBtn');
            const currentDayLabel = document.getElementById('currentDayLabel');
            const nextDayBtn = document.getElementById('nextDayBtn');
            const addTradeBtn = document.getElementById('addTradeBtn');
            const addWithdrawalBtn = document.getElementById('addWithdrawalBtn');
            const monthCommentsInput = document.getElementById('monthCommentsInput');
            
            // Progress elements
            const progressFill = document.getElementById('progressFill');
            const progressStart = document.getElementById('progressStart');
            const progressCurrent = document.getElementById('progressCurrent');
            const progressTarget = document.getElementById('progressTarget');
            
            // Balance elements
            const startingBalanceValue = document.getElementById('startingBalanceValue');
            const currentBalanceValue = document.getElementById('currentBalanceValue');
            const dayResultValue = document.getElementById('dayResultValue');
            const saveBalanceBtn = document.getElementById('saveBalanceBtn');
            const cancelBalanceBtn = document.getElementById('cancelBalanceBtn');
            
            // Clear buttons
            const clearCurrentDayBtn = document.getElementById('clearCurrentDayBtn');
            const clearAllDataBtn = document.getElementById('clearAllDataBtn');
            
            // Elements for General tab
            const currentGeneralDate = document.getElementById('currentGeneralDate');
            const generalTable = document.getElementById('generalTable');
            const saveWithdrawalBtn = document.getElementById('saveWithdrawalBtn');
            const cancelWithdrawalBtn = document.getElementById('cancelWithdrawalBtn');
            const withdrawalTable = document.getElementById('withdrawalTable');
            const targetModal = document.getElementById('targetModal');
            const targetModalTitle = document.getElementById('targetModalTitle');
            const targetInput = document.getElementById('targetInput');
            const applyToDayBtn = document.getElementById('applyToDayBtn');
            const applyToAllBtn = document.getElementById('applyToAllBtn');
            const cancelTargetBtn = document.getElementById('cancelTargetBtn');

            // Elements for emotion and comment modals
            const clearEmotionBtn = document.getElementById('clearEmotionBtn');
            const commentsInput = document.getElementById('commentsInput');
            const saveCommentBtn = document.getElementById('saveCommentBtn');
            const cancelCommentBtn = document.getElementById('cancelCommentBtn');

            // Elements for trade amount modal
            const saveTradeAmountBtn = document.getElementById('saveTradeAmountBtn');
            const cancelTradeAmountBtn = document.getElementById('cancelTradeAmountBtn');

            // Elements for withdrawal action modal
            const editWithdrawalBtn = document.getElementById('editWithdrawalBtn');
            const deleteWithdrawalBtn = document.getElementById('deleteWithdrawalBtn');
            const cancelWithdrawalActionBtn = document.getElementById('cancelWithdrawalActionBtn');

            // New elements for General tab navigation
            const prevMonthBtn = document.getElementById('prevMonthBtn');
            const currentMonthLabel = document.getElementById('currentMonthLabel');
            const nextMonthBtn = document.getElementById('nextMonthBtn');

            // State
            let currentDate = new Date();
            let trades = [];
            let currentCell = null;
            let currentTradeIndex = null;
            let currentColumnType = null;
            let tradeData = {};
            let historyData = JSON.parse(localStorage.getItem('tradeHistory')) || {};
            let generalData = JSON.parse(localStorage.getItem('generalData')) || {};
            let withdrawalData = JSON.parse(localStorage.getItem('withdrawalData')) || {};
            let monthCommentsData = JSON.parse(localStorage.getItem('monthCommentsData')) || {};
            let appSettings = JSON.parse(localStorage.getItem('appSettings')) || {
                initialBalance: 10000,
                startingBalance: 10000,
                currentBalance: 10000
            };
            
            // Emotion mapping
            const emotionMap = {
                'fear': '😨 Fear',
                'greed': '🤑 Greed',
                'joy': '😁 Joy',
                'uncertainty': '😕 Uncertainty',
                'neutral': '😐 Neutral',
                'frustration': '😤 Frustration',
                'contemplation': '🤔 Contemplation',
                'boredom': '😴 Boredom'
            };
            
            // UI Settings
            let uiSettings = JSON.parse(localStorage.getItem('uiSettings')) || {
                showProgressBar: true
            };

            // Variables for target management
            let currentTargetDay = null;
            let currentTargetType = null;

            // Variables for withdrawal management
            let currentWithdrawalDate = null;
            let currentWithdrawalIndex = null;
            let isEditingWithdrawal = false;

            // Variables for General tab month navigation
            let currentGeneralYear, currentGeneralMonth;
            
            // Initialize
            function init() {
                console.log('Initializing trading diary app');
                if (currentDateEl) currentDateEl.textContent = formatDate(currentDate);
                
                // Load balance settings
                if (appSettings.startingBalance && startingBalanceValue) {
                    startingBalanceValue.textContent = formatNumber(appSettings.startingBalance);
                }
                
                console.log('Starting Balance element:', startingBalanceValue);
                console.log('Balance modal:', balanceModal);
                
                // Add global click listener for debugging
                document.addEventListener('click', (e) => {
                    console.log('Click on:', e.target);
                    console.log('Class:', e.target.className);
                });
                
                // Пересчитываем текущий баланс с учетом всех сделок и выводов
                recalculateCurrentBalance();
                
                const dateKey = formatDateKey(currentDate);
                if (historyData[dateKey]) {
                    // Исправление: глубокое копирование данных для дня
                    tradeData = JSON.parse(JSON.stringify(historyData[dateKey]));
                    trades = tradeData.trades || [];
                    renderTable();
                    updateDayResultForCurrentDate();
                } else {
                    initTrades();
                    renderTable();
                }
                
                // Initialize General tab
                initGeneralTab();
                
                renderHistory();
                
                // Initialize withdrawal table
                renderWithdrawalTable();
                
                // Load month comments
                loadMonthComments();
                
                // Update navigation buttons
                updateNavigationButtons();
                
                // Update current day label
                updateCurrentDayLabel();
                
                // Проверяем, можно ли редактировать текущую дату
                updateEditPermissions();
                
                // Initialize progress bar
                updateProgressBar();
                
                // Initialize progress bar visibility
                updateProgressBarVisibility();
                console.log('App initialized successfully');

                // Log Starting Balance styles after init
                setTimeout(logStartingBalanceStyles, 1000);
            }
            
            // Функция для добавления новой сделки без полной перерисовки
            function addTradeToTable() {
                const newTrade = {
                    tradeAmount: null,
                    result: null,
                    emotion: null,
                    comment: ''
                };
                
                trades.push(newTrade);
                
                const tbody = tradingTable.querySelector('tbody');
                const row = createTableRow(trades.length - 1, newTrade);
                tbody.appendChild(row);
                
                // Обновляем права доступа для ячеек
                updateEditPermissions();
                refreshAllDisplays();
            }
            
            function saveTradeData() {
                // Сохраняем данные только если есть хотя бы одна заполненная сделка
                if (!hasDayData(trades)) {
                    const dateKey = formatDateKey(currentDate);
                    // Удаляем пустые данные из истории
                    delete historyData[dateKey];
                } else {
                    tradeData.trades = trades;
                    const dateKey = formatDateKey(currentDate);
                    historyData[dateKey] = JSON.parse(JSON.stringify(tradeData)); // Глубокое копирование
                }
                
                localStorage.setItem('tradeHistory', JSON.stringify(historyData));
            }
            
            function saveSettings() {
                localStorage.setItem('appSettings', JSON.stringify(appSettings));
            }
            
            function saveUISettings() {
                localStorage.setItem('uiSettings', JSON.stringify(uiSettings));
            }

            // Функция для проверки, есть ли в дне какие-либо данные
            function hasDayData(dayTrades) {
                if (!dayTrades || dayTrades.length === 0) return false;
                
                for (let i = 0; i < dayTrades.length; i++) {
                    const trade = dayTrades[i];
                    if (trade.tradeAmount !== null || trade.result !== null || 
                        trade.emotion !== null || (trade.comment && trade.comment !== '')) {
                        return true;
                    }
                }
                return false;
            }

            // Функция для пересчета текущего баланса с учетом всех сделок и выводов
            function recalculateCurrentBalance() {
                let totalProfitLoss = 0;
                let totalWithdrawals = 0;
                
                // Суммируем все прибыли/убытки из истории
                Object.keys(historyData).forEach(dateKey => {
                    const dayData = historyData[dateKey];
                    if (dayData.trades) {
                        dayData.trades.forEach(trade => {
                            if (trade.result) {
                                if (trade.result.type === 'profit') {
                                    totalProfitLoss += trade.result.amount;
                                } else if (trade.result.type === 'loss') {
                                    totalProfitLoss -= trade.result.amount;
                                }
                            }
                        });
                    }
                });
                
                // Суммируем все выводы
                Object.keys(withdrawalData).forEach(dateKey => {
                    withdrawalData[dateKey].forEach(withdrawal => {
                        totalWithdrawals += withdrawal.amount;
                    });
                });
                
                // Обновляем текущий баланс
                appSettings.currentBalance = appSettings.startingBalance + totalProfitLoss - totalWithdrawals;
                
                // ВСЕГДА обновляем отображение
                if (currentBalanceValue) {
                    currentBalanceValue.textContent = formatNumber(appSettings.currentBalance);
                }
                
                saveSettings();
                
                return appSettings.currentBalance;
            }

            // Функция для обновления результата дня для текущей даты
            function updateDayResultForCurrentDate() {
                if (!dayResultValue) return;
                
                let dayTotal = 0;
                // Используем текущие данные trades вместо historyData для мгновенного обновления
                for (let i = 0; i < trades.length; i++) {
                    const trade = trades[i];
                    if (trade.result !== null) {
                        const amount = trade.result.amount;
                        const type = trade.result.type;
                        
                        if (type === 'profit') {
                            dayTotal += amount;
                        } else if (type === 'loss') {
                            dayTotal -= amount;
                        }
                    }
                }
                
                dayResultValue.textContent = formatNumber(dayTotal);
                if (dayTotal > 0) {
                    dayResultValue.classList.add('positive');
                    dayResultValue.classList.remove('negative');
                } else if (dayTotal < 0) {
                    dayResultValue.classList.add('negative');
                    dayResultValue.classList.remove('positive');
                } else {
                    dayResultValue.classList.remove('positive', 'negative');
                }
                
                // Сохраняем данные
                saveTradeData();
            }
            
            // Функция для обновления отображения результата дня
            function updateDayResultDisplay() {
                if (!dayResultValue) return;
                
                const dateKey = formatDateKey(currentDate);
                const dayData = historyData[dateKey];
                
                if (dayData && dayData.trades) {
                    let dayTotal = 0;
                    for (let i = 0; i < dayData.trades.length; i++) {
                        const trade = dayData.trades[i];
                        if (trade.result !== null) {
                            const amount = trade.result.amount;
                            const type = trade.result.type;
                            
                            if (type === 'profit') {
                                dayTotal += amount;
                            } else if (type === 'loss') {
                                dayTotal -= amount;
                            }
                        }
                    }
                    
                    dayResultValue.textContent = formatNumber(dayTotal);
                    if (dayTotal > 0) {
                        dayResultValue.classList.add('positive');
                        dayResultValue.classList.remove('negative');
                    } else if (dayTotal < 0) {
                        dayResultValue.classList.add('negative');
                        dayResultValue.classList.remove('positive');
                    } else {
                        dayResultValue.classList.remove('positive', 'negative');
                    }
                } else {
                    dayResultValue.textContent = '0';
                    dayResultValue.classList.remove('positive', 'negative');
                }
            }

            // Получить сегодняшнюю дату в локальном часовом поясе
            function getToday() {
                const now = new Date();
                return new Date(now.getFullYear(), now.getMonth(), now.getDate());
            }

            // Форматирование даты в локальном часовом поясе
            function formatDate(date) {
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}.${month}.${year}`;
            }
            
            // Форматирование ключа даты в локальном часовом поясе
            function formatDateKey(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }
            
            // Парсинг ключа даты в локальном часовом поясе
            function parseDateKey(dateKey) {
                const [year, month, day] = dateKey.split('-').map(Number);
                return new Date(year, month - 1, day);
            }
            
            function formatNumber(amount) {
                // Проверяем, является ли число целым
                if (Number.isInteger(amount)) {
                    return new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(amount);
                } else {
                    // Для дробных чисел сохраняем значимые цифры
                    return new Intl.NumberFormat('en-US', { maximumFractionDigits: 10 }).format(amount);
                }
            }
            
            function initTrades() {
                trades = [];
                for (let i = 0; i < 5; i++) {
                    trades.push({
                        tradeAmount: null,
                        result: null,
                        emotion: null,
                        comment: ''
                    });
                }
                tradeData.trades = trades;
            }
            
            function renderTable() {
                if (!tradingTable) return;
                
                const tbody = tradingTable.querySelector('tbody');
                
                if (!tbody) return;
                
                // Очищаем таблицу только если это первоначальная отрисовка или количество сделок изменилось
                if (tbody.children.length !== trades.length) {
                    tbody.innerHTML = '';
                    
                    for (let i = 0; i < trades.length; i++) {
                        const row = createTableRow(i, trades[i]);
                        tbody.appendChild(row);
                    }
                } else {
                    // Обновляем только измененные ячейки
                    for (let i = 0; i < trades.length; i++) {
                        updateTableRow(tbody.children[i], i, trades[i]);
                    }
                }
                
                // Обновляем права доступа для ячеек
                updateEditPermissions();
            }
            
            // Создание строки таблицы
            function createTableRow(index, trade) {
                const row = document.createElement('tr');
                
                const tradeCell = document.createElement('td');
                tradeCell.textContent = index + 1;
                tradeCell.className = 'trade-header';
                row.appendChild(tradeCell);
                
                const tradeAmountCell = document.createElement('td');
                tradeAmountCell.className = 'cell';

                if (trade.tradeAmount !== null && trade.tradeAmount !== 0) {
                    tradeAmountCell.textContent = formatNumber(trade.tradeAmount);
                    if (trade.tradeAmount > 0) {
                        tradeAmountCell.classList.add('amount-positive');
                    } else if (trade.tradeAmount < 0) {
                        tradeAmountCell.classList.add('amount-negative');
                    } else {
                        tradeAmountCell.classList.add('amount-zero');
                    }
                } else {
                    tradeAmountCell.textContent = 'Click to enter amount';
                    tradeAmountCell.style.color = 'var(--hint-color)';
                    tradeAmountCell.style.fontStyle = 'italic';
                }
                
                tradeAmountCell.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    currentCell = tradeAmountCell;
                    currentTradeIndex = index;
                    currentColumnType = 'amount';
                    if (tradeAmountInput) tradeAmountInput.value = (trade.tradeAmount && trade.tradeAmount !== 0) ? trade.tradeAmount : '';
                    if (tradeAmountModal) tradeAmountModal.style.display = 'flex';
                });
                
                row.appendChild(tradeAmountCell);
                
                const resultCell = document.createElement('td');
                resultCell.className = 'cell';

                if (trade.result !== null) {
                    const amount = trade.result.amount;
                    const type = trade.result.type;

                    if (type === 'profit') {
                        resultCell.className += ' profit';
                        if (amount > 0) {
                            resultCell.classList.add('amount-positive');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-negative');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        resultCell.innerHTML = `<div class="cell-content">+${formatNumber(amount)}</div>`;
                    } else if (type === 'loss') {
                        resultCell.className += ' loss';
                        if (amount > 0) {
                            resultCell.classList.add('amount-negative');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-positive');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        resultCell.innerHTML = `<div class="cell-content">-${formatNumber(amount)}</div>`;
                    } else if (type === 'refund') {
                        resultCell.className += ' refund';
                        if (amount > 0) {
                            resultCell.classList.add('amount-positive');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-negative');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        if (amount > 0) {
                            resultCell.innerHTML = `<div class="cell-content">Refund: ${formatNumber(amount)}</div>`;
                        } else {
                            resultCell.innerHTML = `<div class="cell-content">Refund</div>`;
                        }
                    }
                }
                
                resultCell.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    currentCell = resultCell;
                    currentTradeIndex = index;
                    currentColumnType = 'result';
                    if (amountInput) amountInput.value = '';
                    if (resultModal) resultModal.style.display = 'flex';
                });
                
                row.appendChild(resultCell);
                
                const emotionCell = document.createElement('td');
                emotionCell.className = 'cell emotion-cell';
                
                if (trade.emotion !== null) {
                    emotionCell.textContent = trade.emotion;
                }
                
                emotionCell.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    currentCell = emotionCell;
                    currentTradeIndex = index;
                    currentColumnType = 'emotion';
                    if (emotionModal) emotionModal.style.display = 'flex';
                });
                
                row.appendChild(emotionCell);
                
                const commentsCell = document.createElement('td');
                commentsCell.className = 'cell comments-cell';
                
                if (trade.comment !== '') {
                    commentsCell.textContent = trade.comment;
                } else {
                    commentsCell.textContent = 'Click to add comment';
                    commentsCell.style.color = 'var(--hint-color)';
                    commentsCell.style.fontStyle = 'italic';
                }
                
                commentsCell.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    currentCell = commentsCell;
                    currentTradeIndex = index;
                    currentColumnType = 'comments';
                    if (commentsInput) commentsInput.value = trade.comment || '';
                    if (commentsModal) commentsModal.style.display = 'flex';
                });
                
                row.appendChild(commentsCell);
                
                return row;
            }
            
            // Обновление строки таблицы
            function updateTableRow(row, index, trade) {
                const cells = row.cells;
                
                // Обновляем ячейку с номером сделки
                cells[0].textContent = index + 1;
                
                // Обновляем ячейку с суммой сделки
                const tradeAmountCell = cells[1];
                tradeAmountCell.className = 'cell';
                if (trade.tradeAmount !== null && trade.tradeAmount !== 0) {
                    tradeAmountCell.textContent = formatNumber(trade.tradeAmount);
                    tradeAmountCell.style.color = '';
                    tradeAmountCell.style.fontStyle = '';
                    if (trade.tradeAmount > 0) {
                        tradeAmountCell.classList.add('amount-positive');
                    } else if (trade.tradeAmount < 0) {
                        tradeAmountCell.classList.add('amount-negative');
                    } else {
                        tradeAmountCell.classList.add('amount-zero');
                    }
                } else {
                    tradeAmountCell.textContent = 'Click to enter amount';
                    tradeAmountCell.style.color = 'var(--hint-color)';
                    tradeAmountCell.style.fontStyle = 'italic';
                }
                
                // Обновляем ячейку с результатом
                const resultCell = cells[2];
                resultCell.className = 'cell';

                if (trade.result !== null) {
                    const amount = trade.result.amount;
                    const type = trade.result.type;

                    if (type === 'profit') {
                        resultCell.className += ' profit';
                        if (amount > 0) {
                            resultCell.classList.add('amount-positive');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-negative');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        resultCell.innerHTML = `<div class="cell-content">+${formatNumber(amount)}</div>`;
                    } else if (type === 'loss') {
                        resultCell.className += ' loss';
                        if (amount > 0) {
                            resultCell.classList.add('amount-negative');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-positive');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        resultCell.innerHTML = `<div class="cell-content">-${formatNumber(amount)}</div>`;
                    } else if (type === 'refund') {
                        resultCell.className += ' refund';
                        if (amount > 0) {
                            resultCell.classList.add('amount-positive');
                        } else if (amount < 0) {
                            resultCell.classList.add('amount-negative');
                        } else {
                            resultCell.classList.add('amount-zero');
                        }
                        if (amount > 0) {
                            resultCell.innerHTML = `<div class="cell-content">Refund: ${formatNumber(amount)}</div>`;
                        } else {
                            resultCell.innerHTML = `<div class="cell-content">Refund</div>`;
                        }
                    }
                } else {
                    resultCell.innerHTML = '';
                }
                
                // Обновляем ячейку с эмоциями
                const emotionCell = cells[3];
                emotionCell.className = 'cell emotion-cell';
                if (trade.emotion !== null) {
                    emotionCell.textContent = emotionMap[trade.emotion] || trade.emotion;
                } else {
                    emotionCell.textContent = '';
                }
                
                // Обновляем ячейку с комментариями
                const commentsCell = cells[4];
                commentsCell.className = 'cell comments-cell';
                if (trade.comment !== '') {
                    commentsCell.textContent = trade.comment;
                } else {
                    commentsCell.textContent = 'Click to add comment';
                    commentsCell.style.color = 'var(--hint-color)';
                    commentsCell.style.fontStyle = 'italic';
                }
            }
            
            function updateTotal() {
                let total = 0;
                let winTrades = 0;
                let lossTrades = 0;
                
                for (let i = 0; i < trades.length; i++) {
                    const trade = trades[i];
                    if (trade.result !== null) {
                        const amount = trade.result.amount;
                        const type = trade.result.type;
                        
                        if (type === 'profit') {
                            total += amount;
                            winTrades++;
                        } else if (type === 'loss') {
                            total -= amount;
                            lossTrades++;
                        }
                    }
                }
                
                // Обновляем результат дня только если это сегодняшний день
                updateDayResultForCurrentDate();
                
                // Пересчитываем общий баланс с учетом всех сделок и выводов
                recalculateCurrentBalance();
                
                // Update progress bar
                updateProgressBar();
                
                const startingBalance = appSettings.startingBalance;
                const profitLossPercent = startingBalance > 0 ? (total / startingBalance) * 100 : 0;
                
                const dateKey = formatDateKey(currentDate);
                if (!generalData[dateKey]) {
                    generalData[dateKey] = {};
                }
                
                generalData[dateKey].actualProfitLoss = profitLossPercent;
                generalData[dateKey].winTrades = winTrades;
                generalData[dateKey].lossTrades = lossTrades;
                
                localStorage.setItem('generalData', JSON.stringify(generalData));
                
                // Auto save data только если есть данные
                if (hasDayData(trades)) {
                    saveTradeData();
                }
                
                updateGeneralTable();
                renderHistory();
            }
            
            // Функция для обновления всех данных при изменении в таблице
            function refreshAllDisplays() {
                recalculateCurrentBalance();
                updateDayResultForCurrentDate();
                renderTable();
                renderHistory();
                updateGeneralTable();
                updateProgressBar();
                
                // Добавьте сохранение данных
                saveTradeData();
            }
            
            function saveGeneralData() {
                localStorage.setItem('generalData', JSON.stringify(generalData));
            }
            
            function saveWithdrawalData() {
                localStorage.setItem('withdrawalData', JSON.stringify(withdrawalData));
            }
            
            function saveMonthCommentsData() {
                localStorage.setItem('monthCommentsData', JSON.stringify(monthCommentsData));
            }
            
            function updateProgressBarVisibility() {
                const progressBarContainer = document.querySelector('.progress-container');
                if (progressBarContainer) {
                    if (uiSettings.showProgressBar) {
                        progressBarContainer.style.display = 'block';
                    } else {
                        progressBarContainer.style.display = 'none';
                    }
                }
            }
            
            function loadDateData(date) {
                // Сохраняем данные текущего дня перед переходом только если есть данные
                if (hasDayData(trades)) {
                    saveTradeData();
                }
                
                const today = getToday();
                const selectedDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                
                // Prevent navigation to future dates
                if (selectedDate > today) {
                    showNotification("Cannot view future dates", "error");
                    return;
                }
                
                currentDate = date;
                if (currentDateEl) currentDateEl.textContent = formatDate(currentDate);
                
                const dateKey = formatDateKey(currentDate);
                
                if (historyData[dateKey]) {
                    // Исправление: глубокое копирование данных для дня
                    tradeData = JSON.parse(JSON.stringify(historyData[dateKey]));
                    trades = tradeData.trades || [];
                } else {
                    tradeData = {};
                    initTrades();
                }
                
                renderTable();
                
                // Update current day label
                updateCurrentDayLabel();
                
                // Calculate balance for the selected day only (don't update the displayed balances)
                let total = 0;
                for (let i = 0; i < trades.length; i++) {
                    const trade = trades[i];
                    if (trade.result !== null) {
                        const amount = trade.result.amount;
                        const type = trade.result.type;
                        
                        if (type === 'profit') {
                            total += amount;
                        } else if (type === 'loss') {
                            total -= amount;
                        }
                    }
                }
                
                // Обновляем результат дня для выбранной даты
                updateDayResultForCurrentDate();
                
                // Обновляем цвет ячейки day result в таблице General
                updateGeneralTable();
                
                // Update progress bar
                updateProgressBar();
                
                // Update progress bar visibility
                updateProgressBarVisibility();
                
                renderHistory();
                updateGeneralTable();
                updateNavigationButtons();
                updateEditPermissions();
                
                // Обновляем цвет ячейки day result в баланс-панели при навигации
                updateDayResultDisplay();
            }
            
            // Функция для обновления метки текущего дня
            function updateCurrentDayLabel() {
                if (!currentDayLabel) return;
                
                const today = getToday();
                const current = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                
                if (current.getTime() === today.getTime()) {
                    currentDayLabel.textContent = 'Today';
                } else {
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    
                    if (current.getTime() === yesterday.getTime()) {
                        currentDayLabel.textContent = 'Yesterday';
                    } else {
                        currentDayLabel.textContent = formatDate(currentDate);
                    }
                }
            }
            
            // Функция для проверки, можно ли редактировать текущую дату
            function canEditCurrentDate() {
                const today = getToday();
                const current = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                
                return current.getTime() === today.getTime();
            }
            
            // Функция для обновления прав доступа к редактированию
            function updateEditPermissions() {
                const canEdit = canEditCurrentDate();
                
                // Блокируем/разблокируем ячейки таблицы
                const cells = document.querySelectorAll('#tradingTable td.cell');
                cells.forEach(cell => {
                    if (canEdit) {
                        cell.classList.remove('disabled');
                    } else {
                        cell.classList.add('disabled');
                    }
                });
                
                // Блокируем/разблокируем кнопку добавления сделки
                if (addTradeBtn) {
                    addTradeBtn.disabled = !canEdit;
                }
            }
            
            function updateNavigationButtons() {
                const today = getToday();
                const current = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                
                // Disable next day button if trying to go to future
                if (nextDayBtn) {
                    const nextDay = new Date(current);
                    nextDay.setDate(nextDay.getDate() + 1);
                    
                    if (nextDay > today) {
                        nextDayBtn.disabled = true;
                    } else {
                        nextDayBtn.disabled = false;
                    }
                }
            }
            
            function renderHistory() {
                if (!historyTable) return;
                
                const tbody = historyTable.querySelector('tbody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                const dates = Object.keys(historyData).sort().reverse();
                
                if (dates.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="2" style="text-align: center;">No records in history</td></tr>';
                    return;
                }
                
                dates.forEach(dateKey => {
                    const data = historyData[dateKey];
                    let dayTotal = 0;
                    
                    if (data.trades) {
                        for (let i = 0; i < data.trades.length; i++) {
                            const trade = data.trades[i];
                            if (trade.result !== null) {
                                const amount = trade.result.amount;
                                const type = trade.result.type;
                                
                                if (type === 'profit') {
                                    dayTotal += amount;
                                } else if (type === 'loss') {
                                    dayTotal -= amount;
                                }
                            }
                        }
                    }
                    
                    const row = document.createElement('tr');
                    
                    const dateCell = document.createElement('td');
                    dateCell.textContent = formatDate(parseDateKey(dateKey));
                    row.appendChild(dateCell);
                    
                    const totalCell = document.createElement('td');
                    if (dayTotal > 0) totalCell.classList.add('positive');
                    else if (dayTotal < 0) totalCell.classList.add('negative');
                    totalCell.textContent = formatNumber(dayTotal);
                    row.appendChild(totalCell);
                    
                    tbody.appendChild(row);
                });
            }
            
            function showNotification(message, type) {
                if (!notification) return;
                
                notification.textContent = message;
                notification.className = `notification ${type}`;
                
                setTimeout(() => {
                    notification.className = 'notification';
                }, 3000);
            }
            
            // Functions for General tab
            function initGeneralTab() {
                const now = new Date();
                currentGeneralYear = now.getFullYear();
                currentGeneralMonth = now.getMonth();
                
                console.log('General tab initialized, currentGeneralYear: ' + currentGeneralYear + ', currentGeneralMonth: ' + currentGeneralMonth);
                if (currentGeneralDate) {
                    console.log('currentGeneralDate element: ' + currentGeneralDate.textContent);
                }
                
                updateGeneralNavigation();
                updateGeneralTable();
                renderWithdrawalTable();
                loadMonthComments();
                updateGeneralEditPermissions();
            }
            
            function updateGeneralNavigation() {
                const monthNames = [
                    "January", "February", "March", "April", "May", "June",
                    "July", "August", "September", "October", "November", "December"
                ];
                
                if (currentMonthLabel) {
                    currentMonthLabel.textContent = monthNames[currentGeneralMonth];
                }
                
                if (currentGeneralDate) {
                    // currentGeneralDate.textContent = formatDate(new Date()); // Removed month label
                    console.log('Month label removed from General');
                }
                
                // Update month navigation buttons
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth();
                
                if (nextMonthBtn) {
                    // Disable next month button if we're viewing current month
                    if (currentGeneralYear === currentYear && currentGeneralMonth === currentMonth) {
                        nextMonthBtn.disabled = true;
                    } else {
                        nextMonthBtn.disabled = false;
                    }
                }
            }
            
            function updateGeneralTable() {
                if (!generalTable) return;
                
                const tbody = generalTable.querySelector('tbody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                
                const daysInMonth = new Date(currentGeneralYear, currentGeneralMonth + 1, 0).getDate();
                
                const today = new Date();
                const currentDay = today.getDate();
                const currentMonthIndex = today.getMonth();
                const currentYearValue = today.getFullYear();
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const row = document.createElement('tr');
                    
                    if (day === currentDay && currentGeneralMonth === currentMonthIndex && currentGeneralYear === currentYearValue) {
                        row.classList.add('current-day');
                    }
                    
                    const dayCell = document.createElement('td');
                    dayCell.textContent = day;
                    row.appendChild(dayCell);
                    
                    const profitTargetCell = document.createElement('td');
                    profitTargetCell.className = 'editable';
                    const profitTargetValue = getGeneralData(day, 'profitTarget') || '-';
                    profitTargetCell.textContent = profitTargetValue !== '-' ? profitTargetValue + '%' : '-';
                    profitTargetCell.dataset.day = day;
                    profitTargetCell.dataset.type = 'profit';
                    
                    // Add click event only if we can edit this month
                    if (canEditGeneralMonth()) {
                        profitTargetCell.addEventListener('click', handleTargetCellClick);
                    } else {
                        profitTargetCell.style.cursor = 'not-allowed';
                        profitTargetCell.style.opacity = '0.6';
                    }
                    
                    row.appendChild(profitTargetCell);
                    
                    const lossTargetCell = document.createElement('td');
                    lossTargetCell.className = 'editable';
                    const lossTargetValue = getGeneralData(day, 'lossTarget') || '-';
                    lossTargetCell.textContent = lossTargetValue !== '-' ? lossTargetValue + '%' : '-';
                    lossTargetCell.dataset.day = day;
                    lossTargetCell.dataset.type = 'loss';
                    
                    // Add click event only if we can edit this month
                    if (canEditGeneralMonth()) {
                        lossTargetCell.addEventListener('click', handleTargetCellClick);
                    } else {
                        lossTargetCell.style.cursor = 'not-allowed';
                        lossTargetCell.style.opacity = '0.6';
                    }
                    
                    row.appendChild(lossTargetCell);
                    
                    const actualCell = document.createElement('td');
                    const actualValue = getGeneralData(day, 'actualProfitLoss') || 0;
                    actualCell.textContent = actualValue !== 0 ? actualValue.toFixed(2) + '%' : '-';
                    if (actualValue > 0) {
                        actualCell.classList.add('positive');
                    } else if (actualValue < 0) {
                        actualCell.classList.add('negative');
                    }
                    row.appendChild(actualCell);
                    
                    const winTradesCell = document.createElement('td');
                    const winTrades = getGeneralData(day, 'winTrades') || 0;
                    winTradesCell.textContent = winTrades > 0 ? winTrades : '-';
                    row.appendChild(winTradesCell);
                    
                    const lossTradesCell = document.createElement('td');
                    const lossTrades = getGeneralData(day, 'lossTrades') || 0;
                    lossTradesCell.textContent = lossTrades > 0 ? lossTrades : '-';
                    row.appendChild(lossTradesCell);
                    
                    tbody.appendChild(row);
                }
            }
            
            function getGeneralData(day, field) {
                const dateKey = `${currentGeneralYear}-${String(currentGeneralMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                return generalData[dateKey] ? generalData[dateKey][field] : null;
            }
            
            function handleTargetCellClick(event) {
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot edit past months", "error");
                    return;
                }
                
                const cell = event.target;
                const day = parseInt(cell.dataset.day);
                const type = cell.dataset.type;
                
                currentTargetDay = day;
                currentTargetType = type;
                
                if (targetModalTitle) {
                    targetModalTitle.textContent = `Set ${type === 'profit' ? 'profit target' : 'loss target'} for day ${day} (%)`;
                }
                
                if (targetInput) {
                    const cellText = cell.textContent;
                    targetInput.value = cellText !== '-' ? cellText.replace('%', '') : '';
                }
                
                if (targetModal) {
                    targetModal.style.display = 'flex';
                }
            }
            
            function canEditGeneralMonth() {
                const now = new Date();
                const currentYear = now.getFullYear();
                const currentMonth = now.getMonth();
                
                // Can only edit current month
                return currentGeneralYear === currentYear && currentGeneralMonth === currentMonth;
            }
            
            function updateGeneralEditPermissions() {
                const canEdit = canEditGeneralMonth();
                
                // Update withdrawal button
                if (addWithdrawalBtn) {
                    if (canEdit) {
                        addWithdrawalBtn.disabled = false;
                        addWithdrawalBtn.style.opacity = '1';
                    } else {
                        addWithdrawalBtn.disabled = true;
                        addWithdrawalBtn.style.opacity = '0.5';
                    }
                }
                
                // Update month comments
                if (monthCommentsInput) {
                    monthCommentsInput.disabled = !canEdit;
                    if (!canEdit) {
                        monthCommentsInput.placeholder = "Cannot edit comments for past months";
                    } else {
                        monthCommentsInput.placeholder = "Enter comments for the current month...";
                    }
                }
            }
            
            function loadGeneralMonth(year, month) {
                currentGeneralYear = year;
                currentGeneralMonth = month;
                
                updateGeneralNavigation();
                updateGeneralTable();
                renderWithdrawalTable();
                loadMonthComments();
                updateGeneralEditPermissions();
            }
            
            function addWithdrawal(amount) {
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot add withdrawals to past months", "error");
                    return;
                }
                
                const today = getToday();
                const dateKey = formatDateKey(today);
                if (!withdrawalData[dateKey]) {
                    withdrawalData[dateKey] = [];
                }
                
                withdrawalData[dateKey].push({
                    date: dateKey,
                    amount: amount
                });
                
                // Вместо прямого изменения баланса, пересчитываем его полностью
                recalculateCurrentBalance();
                
                saveWithdrawalData();
                saveSettings();
                renderWithdrawalTable();
                
                showNotification(`Withdrawal ${formatNumber(amount)} saved successfully`, 'success');
            }
            
            function editWithdrawal(dateKey, index, newAmount) {
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot edit withdrawals in past months", "error");
                    return;
                }
                
                if (!withdrawalData[dateKey] || !withdrawalData[dateKey][index]) return;
                
                const oldAmount = withdrawalData[dateKey][index].amount;
                withdrawalData[dateKey][index].amount = newAmount;
                
                // Вместо прямого изменения баланса, пересчитываем его полностью
                recalculateCurrentBalance();
                
                saveWithdrawalData();
                saveSettings();
                renderWithdrawalTable();
                
                showNotification(`Withdrawal updated to ${formatNumber(newAmount)}`, 'success');
            }
            
            function deleteWithdrawal(dateKey, index) {
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot delete withdrawals from past months", "error");
                    return;
                }
                
                if (!withdrawalData[dateKey] || !withdrawalData[dateKey][index]) return;
                
                const amount = withdrawalData[dateKey][index].amount;
                
                withdrawalData[dateKey].splice(index, 1);
                
                if (withdrawalData[dateKey].length === 0) {
                    delete withdrawalData[dateKey];
                }
                
                // Вместо прямого изменения баланса, пересчитываем его полностью
                recalculateCurrentBalance();
                
                saveWithdrawalData();
                saveSettings();
                renderWithdrawalTable();
                
                showNotification(`Withdrawal ${formatNumber(amount)} deleted`, 'success');
            }
            
            function renderWithdrawalTable() {
                if (!withdrawalTable) return;
                
                const tbody = withdrawalTable.querySelector('tbody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                
                const currentMonthKey = `${currentGeneralYear}-${String(currentGeneralMonth + 1).padStart(2, '0')}`;
                let totalWithdrawal = 0;
                let hasWithdrawals = false;
                
                Object.keys(withdrawalData).forEach(dateKey => {
                    if (dateKey.startsWith(currentMonthKey)) {
                        withdrawalData[dateKey].forEach((withdrawal, index) => {
                            hasWithdrawals = true;
                            const row = document.createElement('tr');
                            row.className = 'editable';
                            row.dataset.date = dateKey;
                            row.dataset.index = index;
                            
                            const dateCell = document.createElement('td');
                            dateCell.textContent = formatDate(parseDateKey(withdrawal.date));
                            row.appendChild(dateCell);
                            
                            const amountCell = document.createElement('td');
                            amountCell.textContent = formatNumber(withdrawal.amount);
                            row.appendChild(amountCell);
                            
                            // Only allow editing if we can edit this month
                            if (canEditGeneralMonth()) {
                                row.addEventListener('click', (e) => {
                                    currentWithdrawalDate = e.currentTarget.dataset.date;
                                    currentWithdrawalIndex = parseInt(e.currentTarget.dataset.index);
                                    
                                    if (withdrawalActionModal) {
                                        withdrawalActionModal.style.display = 'flex';
                                    }
                                });
                            } else {
                                row.style.cursor = 'not-allowed';
                                row.style.opacity = '0.6';
                            }
                            
                            tbody.appendChild(row);
                            
                            totalWithdrawal += withdrawal.amount;
                        });
                    }
                });
                
                if (!hasWithdrawals) {
                    const emptyRow = document.createElement('tr');
                    const emptyCell = document.createElement('td');
                    emptyCell.colSpan = 2;
                    emptyCell.textContent = 'No withdrawals for this month';
                    emptyCell.style.textAlign = 'center';
                    emptyCell.style.fontStyle = 'italic';
                    emptyCell.style.color = 'var(--hint-color)';
                    emptyRow.appendChild(emptyCell);
                    tbody.appendChild(emptyRow);
                } else if (totalWithdrawal > 0) {
                    const totalRow = document.createElement('tr');
                    totalRow.style.fontWeight = 'bold';
                    
                    const totalLabelCell = document.createElement('td');
                    totalLabelCell.textContent = 'Total:';
                    totalRow.appendChild(totalLabelCell);
                    
                    const totalAmountCell = document.createElement('td');
                    totalAmountCell.textContent = formatNumber(totalWithdrawal);
                    totalRow.appendChild(totalAmountCell);
                    
                    tbody.appendChild(totalRow);
                }
            }
            
            function applyTargetToDay(value) {
                if (!currentTargetDay || !currentTargetType) return;
                
                const dateKey = `${currentGeneralYear}-${String(currentGeneralMonth + 1).padStart(2, '0')}-${String(currentTargetDay).padStart(2, '0')}`;
                
                if (!generalData[dateKey]) {
                    generalData[dateKey] = {};
                }
                
                generalData[dateKey][currentTargetType + 'Target'] = parseFloat(value);
                
                localStorage.setItem('generalData', JSON.stringify(generalData));
                updateGeneralTable();
                
                if (targetModal) {
                    targetModal.style.display = 'none';
                }
                
                showNotification(`Target for day ${currentTargetDay} set`, 'success');
            }
            
            function applyTargetToAll(value) {
                if (!currentTargetType) return;
                
                const daysInMonth = new Date(currentGeneralYear, currentGeneralMonth + 1, 0).getDate();
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateKey = `${currentGeneralYear}-${String(currentGeneralMonth + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    
                    if (!generalData[dateKey]) {
                        generalData[dateKey] = {};
                    }
                    
                    generalData[dateKey][currentTargetType + 'Target'] = parseFloat(value);
                }
                
                saveGeneralData();
                updateGeneralTable();
                
                closeModal();
                
                showNotification(`Targets for all days set (${value}%)`, 'success');
            }
            
            function loadMonthComments() {
                if (!monthCommentsInput) return;
                
                const monthKey = `${currentGeneralYear}-${currentGeneralMonth + 1}`;
                monthCommentsInput.value = monthCommentsData[monthKey] || '';
            }
            
            function saveMonthComments() {
                if (!monthCommentsInput) return;
                
                // Check if we can edit this month
                if (!canEditGeneralMonth()) {
                    showNotification("Cannot edit comments for past months", "error");
                    return;
                }
                
                const monthKey = `${currentGeneralYear}-${currentGeneralMonth + 1}`;
                monthCommentsData[monthKey] = monthCommentsInput.value;
                saveMonthCommentsData();
            }

            // Event Listeners
            if (prevDayBtn) {
                prevDayBtn.addEventListener('click', () => {
                    const newDate = new Date(currentDate);
                    newDate.setDate(newDate.getDate() - 1);
                    loadDateData(newDate);
                });
            }
            
            if (currentDayLabel) {
                currentDayLabel.addEventListener('click', () => {
                    loadDateData(getToday());
                });
            }
            
            if (nextDayBtn) {
                nextDayBtn.addEventListener('click', () => {
                    const newDate = new Date(currentDate);
                    newDate.setDate(newDate.getDate() + 1);
                    loadDateData(newDate);
                });
            }
            
            // Month navigation for General tab
            if (prevMonthBtn) {
                prevMonthBtn.addEventListener('click', () => {
                    let newMonth = currentGeneralMonth - 1;
                    let newYear = currentGeneralYear;
                    
                    if (newMonth < 0) {
                        newMonth = 11;
                        newYear--;
                    }
                    
                    loadGeneralMonth(newYear, newMonth);
                });
            }
            
            if (nextMonthBtn) {
                nextMonthBtn.addEventListener('click', () => {
                    const now = new Date();
                    const currentYear = now.getFullYear();
                    const currentMonth = now.getMonth();
                    
                    // Prevent navigation to future months
                    if (currentGeneralYear === currentYear && currentGeneralMonth === currentMonth) {
                        showNotification("Cannot view future months", "error");
                        return;
                    }
                    
                    let newMonth = currentGeneralMonth + 1;
                    let newYear = currentGeneralYear;
                    
                    if (newMonth > 11) {
                        newMonth = 0;
                        newYear++;
                    }
                    
                    // Check if we're trying to navigate to a future month
                    if (newYear > currentYear || (newYear === currentYear && newMonth > currentMonth)) {
                        showNotification("Cannot view future months", "error");
                        return;
                    }
                    
                    loadGeneralMonth(newYear, newMonth);
                });
            }
            
            if (addTradeBtn) {
                addTradeBtn.addEventListener('click', () => {
                    // Проверяем, можно ли редактировать эту дату
                    if (!canEditCurrentDate()) return;
                    
                    addTradeToTable();
                    // Не сохраняем автоматически при добавлении пустой сделки
                });
            }
            
            if (addWithdrawalBtn) {
                addWithdrawalBtn.addEventListener('click', () => {
                    // Check if we can edit this month
                    if (!canEditGeneralMonth()) {
                        showNotification("Cannot add withdrawals to past months", "error");
                        return;
                    }
                    
                    isEditingWithdrawal = false;
                    if (withdrawalAmountInput) withdrawalAmountInput.value = '';
                    if (withdrawalModal) withdrawalModal.style.display = 'flex';
                });
            }
            
            if (monthCommentsInput) {
                monthCommentsInput.addEventListener('change', saveMonthComments);
                monthCommentsInput.addEventListener('blur', saveMonthComments);
            }
            
            // Remove conflicting event listeners that were causing issues
            // with reset and clear buttons
            
            // Закрытие модальных окон по клавише Escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeModal();
                }
            });

            if (clearCurrentDayBtn) {
                clearCurrentDayBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to clear current day data?')) {
                        const dateKey = formatDateKey(currentDate);
                        delete historyData[dateKey];
                        saveTradeData();
                        
                        initTrades();
                        renderTable();
                        updateTotal();
                        
                        showNotification('Current day data cleared', 'success');
                    }
                });
            }
            
            if (clearAllDataBtn) {
                clearAllDataBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to clear ALL history? This action cannot be undone.')) {
                        historyData = {};
                        generalData = {};
                        withdrawalData = {};
                        monthCommentsData = {};
                        appSettings = {
                            initialBalance: 10000,
                            startingBalance: 10000,
                            currentBalance: 10000
                        };
                        
                        saveTradeData();
                        saveGeneralData();
                        saveWithdrawalData();
                        saveMonthCommentsData();
                        saveSettings();
                        
                        if (startingBalanceValue) startingBalanceValue.textContent = '10000';
                        if (currentBalanceValue) currentBalanceValue.textContent = '10000';
                        
                        initTrades();
                        renderTable();
                        updateTotal();
                        renderHistory();
                        renderWithdrawalTable();
                        updateGeneralTable();
                        
                        showNotification('All history cleared', 'success');
                    }
                });
            }
            
            // Modal event listeners - ИСПРАВЛЕННЫЕ ОБРАБОТЧИКИ
            const resultModalButtons = resultModal?.querySelectorAll('.modal-btn');
            if (resultModalButtons) {
                resultModalButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        
                        const value = button.dataset.value;
                        const amount = parseFloat(amountInput?.value.replace(',', '.'));
                        
                        if (currentTradeIndex !== null && value === 'reset') {
                            trades[currentTradeIndex].result = null;
                            currentCell.className = 'cell';
                            currentCell.innerHTML = '';
                            
                            updateTotal();
                            refreshAllDisplays();
                            closeModal();
                        } else if (currentTradeIndex !== null && value === 'refund') {
                            currentCell.className = 'cell refund';
                            if (!isNaN(amount) && amount > 0) {
                                currentCell.innerHTML = `<div class="cell-content">Refund: ${formatNumber(amount)}</div>`;
                                trades[currentTradeIndex].result = { type: 'refund', amount: amount };
                            } else {
                                currentCell.innerHTML = `<div class="cell-content">Refund</div>`;
                                trades[currentTradeIndex].result = { type: 'refund', amount: 0 };
                            }
                            
                            updateTotal();
                            refreshAllDisplays();
                            closeModal();
                        } else if (currentTradeIndex !== null && !isNaN(amount) && amount > 0) {
                            if (value === 'profit') {
                                currentCell.className = 'cell profit';
                                currentCell.innerHTML = `<div class="cell-content">+${formatNumber(amount)}</div>`;
                                trades[currentTradeIndex].result = { type: 'profit', amount: amount };
                            } else if (value === 'loss') {
                                currentCell.className = 'cell loss';
                                currentCell.innerHTML = `<div class="cell-content">-${formatNumber(amount)}</div>`;
                                trades[currentTradeIndex].result = { type: 'loss', amount: amount };
                            }
                            
                            updateTotal();
                            refreshAllDisplays();
                            closeModal();
                        } else if (currentTradeIndex !== null && value !== 'reset' && value !== 'refund') {
                            showNotification('Enter a valid positive amount', 'error');
                            if (amountInput) {
                                amountInput.classList.add('error-input');
                                setTimeout(() => amountInput.classList.remove('error-input'), 10);
                            }
                            // НЕ закрываем модальное окно при ошибке
                            return;
                        } else if (currentTradeIndex === null) {
                            showNotification('No trade selected', 'error');
                            closeModal();
                            return;
                        }
                    });
                });
            }
            
            if (resultModal) {
                resultModal.addEventListener('click', (e) => {
                    if (e.target === resultModal) {
                        closeModal();
                    }
                });
            }
            
            // Close modal when pressing Enter in amount input
            if (amountInput) {
                amountInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        // Trigger the first button's action (profit)
                        const profitBtn = document.querySelector('.profit-btn[data-value]');
                        if (profitBtn) {
                            profitBtn.click();
                        }
                    }
                });
            }
            
            // ИСПРАВЛЕННЫЙ ОБРАБОТЧИК для сохранения суммы сделки
            if (saveTradeAmountBtn) {
                saveTradeAmountBtn.addEventListener('click', () => {
                    // Валидация введенных данных
                    const inputValue = tradeAmountInput?.value?.trim();
                    
                    // Если поле пустое или значение равно 0, сбрасываем сумму сделки
                    if (!inputValue || inputValue === '0') {
                        trades[currentTradeIndex].tradeAmount = null;
                        currentCell.textContent = 'Click to enter amount';
                        currentCell.style.color = 'var(--hint-color)';
                        currentCell.style.fontStyle = 'italic';
                    } else {
                        const amount = parseFloat(inputValue.replace(',', '.'));
                        if (isNaN(amount)) {
                            showNotification('Please enter a valid number', 'error');
                            return;
                        }
                        
                        if (amount <= 0) {
                            showNotification('Trade amount must be greater than 0', 'error');
                            return;
                        }
                        
                        // Проверка на слишком большое значение
                        if (amount > 100000) { // 100,000
                            showNotification('Trade amount is too large', 'error');
                            return;
                        }
                        
                        trades[currentTradeIndex].tradeAmount = amount;
                        currentCell.textContent = formatNumber(amount);
                        currentCell.style.color = '';
                        currentCell.style.fontStyle = '';
                    }
                    
                    saveTradeData();
                    updateTotal();
                    refreshAllDisplays();
                    closeModal();
                });
            }
            
            // Валидация ввода в поле суммы сделки (реальное время)
            if (tradeAmountInput) {
                tradeAmountInput.addEventListener('input', function() {
                    // Убираем все, кроме цифр, точки и запятой
                    this.value = this.value.replace(/[^0-9.,]/g, '');
                });
            }

            // Валидация ввода в поле суммы результата (реальное время)
            if (amountInput) {
                amountInput.addEventListener('input', function() {
                    // Убираем все, кроме цифр, точки и запятой
                    this.value = this.value.replace(/[^0-9.,]/g, '');
                });
            }
            
            if (cancelTradeAmountBtn) {
                cancelTradeAmountBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (tradeAmountModal) {
                tradeAmountModal.addEventListener('click', (e) => {
                    if (e.target === tradeAmountModal) {
                        closeModal();
                    }
                });
            }
            
            // Close trade amount modal when pressing Enter in trade amount input
            if (tradeAmountInput) {
                tradeAmountInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (saveTradeAmountBtn) saveTradeAmountBtn.click();
                    }
                });
            }
            
            // ИСПРАВЛЕНИЕ: Правильная обработка сохранения вывода (добавление или редактирование)
            if (saveWithdrawalBtn) {
                saveWithdrawalBtn.addEventListener('click', () => {
                    const amount = parseFloat(withdrawalAmountInput?.value.replace(',', '.'));
                    if (!isNaN(amount) && amount > 0) {
                        if (isEditingWithdrawal && currentWithdrawalDate !== null && currentWithdrawalIndex !== null) {
                            editWithdrawal(currentWithdrawalDate, currentWithdrawalIndex, amount);
                        } else {
                            addWithdrawal(amount);
                        }
                        isEditingWithdrawal = false;
                        closeModal();
                    } else {
                        showNotification('Enter a valid positive amount', 'error');
                        if (withdrawalAmountInput) {
                            withdrawalAmountInput.classList.add('error-input');
                            setTimeout(() => withdrawalAmountInput.classList.remove('error-input'), 1000);
                        }
                    }
                });
            }
            
            if (cancelWithdrawalBtn) {
                cancelWithdrawalBtn.addEventListener('click', () => {
                    isEditingWithdrawal = false;
                    closeModal();
                });
            }
            
            if (withdrawalModal) {
                withdrawalModal.addEventListener('click', (e) => {
                    if (e.target === withdrawalModal) {
                        isEditingWithdrawal = false;
                        closeModal();
                    }
                });
            }
            
            // Close withdrawal modal when pressing Enter in withdrawal amount input
            if (withdrawalAmountInput) {
                withdrawalAmountInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (saveWithdrawalBtn) saveWithdrawalBtn.click();
                    }
                });
            }
            
            // ИСПРАВЛЕНИЕ: Установка флага редактирования при нажатии на Edit
            if (editWithdrawalBtn) {
                editWithdrawalBtn.addEventListener('click', () => {
                    if (currentWithdrawalDate !== null && currentWithdrawalIndex !== null) {
                        isEditingWithdrawal = true;
                        const withdrawal = withdrawalData[currentWithdrawalDate][currentWithdrawalIndex];
                        if (withdrawalAmountInput) withdrawalAmountInput.value = withdrawal.amount;
                        if (withdrawalModal) withdrawalModal.style.display = 'flex';
                        if (withdrawalActionModal) withdrawalActionModal.style.display = 'none';
                    }
                });
            }
            
            if (deleteWithdrawalBtn) {
                deleteWithdrawalBtn.addEventListener('click', () => {
                    if (currentWithdrawalDate !== null && currentWithdrawalIndex !== null) {
                        deleteWithdrawal(currentWithdrawalDate, currentWithdrawalIndex);
                        if (withdrawalActionModal) withdrawalActionModal.style.display = 'none';
                    }
                });
            }
            
            if (cancelWithdrawalActionBtn) {
                cancelWithdrawalActionBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (withdrawalActionModal) {
                withdrawalActionModal.addEventListener('click', (e) => {
                    if (e.target === withdrawalActionModal) {
                        closeModal();
                    }
                });
            }
            
            // Close withdrawal action modal when pressing Enter
            withdrawalActionModal.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    withdrawalActionModal.style.display = 'none';
                }
            });
            
            const emotionOptions = emotionModal?.querySelectorAll('.emotion-option');
            if (emotionOptions) {
                emotionOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const emotion = option.dataset.emotion;
                        trades[currentTradeIndex].emotion = emotion;
                        // Display using emotion map
                        currentCell.textContent = emotionMap[emotion];
                        saveTradeData();
                        updateTotal();
                        refreshAllDisplays();
                        closeModal();
                    });
                });
            }
            
            // Close emotion modal when clicking outside
            if (emotionModal) {
                emotionModal.addEventListener('click', (e) => {
                    if (e.target === emotionModal) {
                        closeModal();
                    }
                });
            }
            
            if (clearEmotionBtn) {
                clearEmotionBtn.addEventListener('click', () => {
                    trades[currentTradeIndex].emotion = null;
                    currentCell.textContent = '';
                    saveTradeData();
                    updateTotal();
                    refreshAllDisplays();
                    closeModal();
                });
            }
            
            // Close emotion modal when pressing Enter in emotion modal
            if (emotionModal) {
                emotionModal.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        closeModal();
                    }
                });
            }
            
            
            if (saveCommentBtn) {
                saveCommentBtn.addEventListener('click', () => {
                    trades[currentTradeIndex].comment = commentsInput.value;
                    currentCell.textContent = commentsInput.value;
                    currentCell.style.color = '';
                    currentCell.style.fontStyle = '';
                    saveTradeData();
                    updateTotal();
                    refreshAllDisplays();
                    closeModal();
                });
            }
            
            if (cancelCommentBtn) {
                cancelCommentBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (commentsModal) {
                commentsModal.addEventListener('click', (e) => {
                    if (e.target === commentsModal) {
                        closeModal();
                    }
                });
            }
            
            // Close comments modal when pressing Enter in comments input
            if (commentsInput) {
                commentsInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (saveCommentBtn) saveCommentBtn.click();
                    }
                });
            }
            
            if (startingBalanceValue) {
                startingBalanceValue.addEventListener('click', () => {
                    console.log('Starting Balance clicked');
                    console.log('Modal display before:', balanceModal ? balanceModal.style.display : 'null');
                    if (balanceInput) balanceInput.value = appSettings.startingBalance;
                    if (balanceModal) balanceModal.style.display = 'flex';
                    console.log('Modal display after:', balanceModal ? balanceModal.style.display : 'null');
                });
            }
            
            if (saveBalanceBtn) {
                saveBalanceBtn.addEventListener('click', () => {
                    const inputValue = balanceInput.value.replace(',', '.');
                    const newBalance = parseFloat(inputValue);
                    if (!isNaN(newBalance)) {
                        appSettings.startingBalance = newBalance;
                        appSettings.currentBalance = newBalance;
                        
                        if (startingBalanceValue) {
                            startingBalanceValue.textContent = formatNumber(newBalance);
                        }
                        
                        if (currentBalanceValue) {
                            currentBalanceValue.textContent = formatNumber(newBalance);
                        }
                        
                        updateTotal();
                        saveSettings();
                        
                        if (balanceModal) balanceModal.style.display = 'none';
                        
                        showNotification('Balance updated', 'success');
                    } else {
                        showNotification('Enter a valid number', 'error');
                    }
                });
            }
            
            if (cancelBalanceBtn) {
                cancelBalanceBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (balanceModal) {
                balanceModal.addEventListener('click', (e) => {
                    if (e.target === balanceModal) {
                        closeModal();
                    }
                });
            }
            
            // Close balance modal when pressing Enter in balance input
            if (balanceInput) {
                balanceInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        if (saveBalanceBtn) saveBalanceBtn.click();
                    }
                });
            }
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.dataset.tab;
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const tabContent = document.getElementById(`${tabId}-tab`);
                    if (tabContent) tabContent.classList.add('active');
                    
                    if (tabId === 'general') {
                        // Reset to current month when switching to General tab
                        const now = new Date();
                        loadGeneralMonth(now.getFullYear(), now.getMonth());
                    } else if (tabId === 'table') {
                        updateProgressBar();
                        // Обновляем цвет ячейки day result при переключении на вкладку "table"
                        updateDayResultForCurrentDate();
                    }
                });
            });
            
            if (applyToDayBtn) {
                applyToDayBtn.addEventListener('click', () => {
                    // Валидация введенных данных
                    const inputValue = targetInput?.value?.trim();
                    if (!inputValue) {
                        showNotification('Please enter a target value', 'error');
                        return;
                    }
                    
                    const value = parseFloat(inputValue.replace(',', '.'));
                    if (isNaN(value)) {
                        showNotification('Please enter a valid number', 'error');
                        return;
                    }
                    
                    // Проверка на разумные пределы целевого значения
                    if (Math.abs(value) > 100) {
                        showNotification('Target value seems too high (max ±100%)', 'error');
                        return;
                    }
                    
                    applyTargetToDay(value);
                });
            }
            
            if (applyToAllBtn) {
                applyToAllBtn.addEventListener('click', () => {
                    // Валидация введенных данных
                    const inputValue = targetInput?.value?.trim();
                    if (!inputValue) {
                        showNotification('Please enter a target value', 'error');
                        return;
                    }
                    
                    const value = parseFloat(inputValue.replace(',', '.'));
                    if (isNaN(value)) {
                        showNotification('Please enter a valid number', 'error');
                        return;
                    }
                    
                    // Проверка на разумные пределы целевого значения
                    if (Math.abs(value) > 100) {
                        showNotification('Target value seems too high (max ±100%)', 'error');
                        return;
                    }
                    
                    applyTargetToAll(value);
                });
            }
            
            // Валидация ввода в поле целевого значения (реальное время)
            if (targetInput) {
                targetInput.addEventListener('input', function() {
                    // Убираем все, кроме цифр, точки, запятой и минуса (для отрицательных значений)
                    this.value = this.value.replace(/[^0-9.,-]/g, '');
                });
            }
            
            if (cancelTargetBtn) {
                cancelTargetBtn.addEventListener('click', () => {
                    closeModal();
                });
            }
            
            if (targetModal) {
                targetModal.addEventListener('click', (e) => {
                    if (e.target === targetModal) {
                        closeModal();
                    }
                });
            }
            
            // Универсальная функция для закрытия модальных окон
            function closeModal() {
                // Закрываем все возможные модальные окна
                const modals = [
                    resultModal,
                    tradeAmountModal,
                    withdrawalModal,
                    withdrawalActionModal,
                    emotionModal,
                    commentsModal,
                    balanceModal,
                    targetModal
                ];
                
                modals.forEach(modal => {
                    if (modal) {
                        modal.style.display = 'none';
                    }
                });
                
                // Сбрасываем переменные состояния
                currentCell = null;
                currentTradeIndex = null;
                currentColumnType = null;
                currentTargetDay = null;
                currentTargetType = null;
                currentWithdrawalDate = null;
                currentWithdrawalIndex = null;
                
                // Сбрасываем значения полей ввода
                if (amountInput) amountInput.value = '';
                if (tradeAmountInput) tradeAmountInput.value = '';
                if (withdrawalAmountInput) withdrawalAmountInput.value = '';
                if (balanceInput) balanceInput.value = '';
                if (targetInput) targetInput.value = '';
                if (commentsInput) commentsInput.value = '';
            }

            // Функция для обновления прогресс-бара
            function updateProgressBar() {
                console.log('updateProgressBar called');
                if (!progressFill || !progressStart || !progressCurrent || !progressTarget) {
                    console.log('Progress bar elements not found');
                    return;
                }
                
                // Получаем текущую дату
                const currentDateKey = formatDateKey(currentDate);
                
                // Получаем данные о целях для текущего дня
                const dayGeneralData = generalData[currentDateKey] || {};
                const profitTarget = dayGeneralData.profitTarget || 2; // По умолчанию 2%
                const lossTarget = dayGeneralData.lossTarget || -2; // По умолчанию -2%
                
                // Вычисляем результат за текущий день
                let dayResult = 0;
                let dayResultPercent = 0;
                
                // Используем текущие данные trades для текущей даты, а не historyData для актуальности
                if (currentDateKey === formatDateKey(new Date())) {
                    // Для текущей даты используем актуальные данные из переменной trades
                    for (let i = 0; i < trades.length; i++) {
                        const trade = trades[i];
                        if (trade.result) {
                            if (trade.result.type === 'profit') {
                                dayResult += trade.result.amount;
                            } else if (trade.result.type === 'loss') {
                                dayResult -= trade.result.amount;
                            }
                        }
                    }
                } else {
                    // Для других дат используем данные из historyData
                    if (historyData[currentDateKey] && historyData[currentDateKey].trades) {
                        historyData[currentDateKey].trades.forEach(trade => {
                            if (trade.result) {
                                if (trade.result.type === 'profit') {
                                    dayResult += trade.result.amount;
                                } else if (trade.result.type === 'loss') {
                                    dayResult -= trade.result.amount;
                                }
                            }
                        });
                    }
                }
                
                // Вычисляем процент результата относительно начального баланса дня
                if (appSettings.startingBalance > 0) {
                    dayResultPercent = (dayResult / appSettings.startingBalance) * 100;
                }
                
                // Обновляем UI элементы
                progressStart.textContent = `${lossTarget.toFixed(1)}%`;
                progressCurrent.textContent = `${dayResultPercent.toFixed(1)}%`;
                progressTarget.textContent = `${profitTarget.toFixed(1)}%`;
                
                // Создаем контейнер для прогресс-бара, чтобы корректно отображать двунаправленный прогресс
                const progressBar = document.querySelector('.progress-bar');
                
                // Очищаем предыдущие элементы прогресса, если они есть
                const existingLossFill = document.querySelector('.progress-loss-fill');
                const existingProfitFill = document.querySelector('.progress-profit-fill');
                const centerMarker = document.querySelector('.center-marker');
                
                if (existingLossFill) existingLossFill.remove();
                if (existingProfitFill) existingProfitFill.remove();
                if (centerMarker) centerMarker.remove();
                
                // Создаем отдельные элементы для отрицательного (убыток) и положительного (прибыль) прогресса
                if (dayResultPercent < 0) {
                    // Красная часть (убыток) - от центра влево
                    const lossFill = document.createElement('div');
                    lossFill.className = 'progress-loss-fill';
                    const lossPercentage = (Math.abs(dayResultPercent) / Math.abs(lossTarget)) * 50;
                    lossFill.style.width = `${Math.min(50, Math.max(0, lossPercentage))}%`;
                    lossFill.style.background = 'var(--progress-loss)';
                    lossFill.style.height = '100%';
                    lossFill.style.position = 'absolute';
                    lossFill.style.left = `${50 - lossPercentage}%`;
                    lossFill.style.top = '0';
                    lossFill.style.borderRadius = '6px';
                    progressBar.appendChild(lossFill);
                } else if (dayResultPercent > 0) {
                    // Зеленая часть (прибыль) - от центра вправо
                    const profitFill = document.createElement('div');
                    profitFill.className = 'progress-profit-fill';
                    const profitPercentage = (dayResultPercent / profitTarget) * 50;
                    profitFill.style.width = `${Math.min(50, Math.max(0, profitPercentage))}%`;
                    profitFill.style.background = 'var(--progress-profit)';
                    profitFill.style.height = '100%';
                    profitFill.style.position = 'absolute';
                    profitFill.style.left = '50%';
                    profitFill.style.top = '0';
                    profitFill.style.borderRadius = '6px';
                    progressBar.appendChild(profitFill);
                }
                
                // Центральная метка (0%)
                const marker = document.createElement('div');
                marker.className = 'center-marker';
                marker.style.position = 'absolute';
                marker.style.left = '50%';
                marker.style.top = '0';
                marker.style.height = '100%';
                marker.style.width = '2px';
                marker.style.background = 'var(--text-color)';
                marker.style.transform = 'translateX(-50%)';
                marker.style.zIndex = '2';
                progressBar.appendChild(marker);
                
                // Убираем основной элемент прогресс-бара, так как теперь у нас двунаправленный прогресс
                progressFill.style.width = '0%';
                console.log('Progress bar updated successfully');
            }
            
            // Initialize the app
            init();

            // Initialize progress bar visibility setting
            const showProgressBarCheckbox = document.getElementById('showProgressBar');
            if (showProgressBarCheckbox) {
                showProgressBarCheckbox.checked = uiSettings.showProgressBar;
                updateProgressBarVisibility();

                showProgressBarCheckbox.addEventListener('change', function() {
                    uiSettings.showProgressBar = this.checked;
                    saveUISettings();
                    updateProgressBarVisibility();
                });
            }

            // Initialize theme buttons
            const lightThemeBtn = document.getElementById('lightThemeBtn');
            const darkThemeBtn = document.getElementById('darkThemeBtn');
            console.log('Theme buttons found:', { lightThemeBtn, darkThemeBtn });
            if (lightThemeBtn) {
                lightThemeBtn.addEventListener('click', () => {
                    console.log('Light Theme button clicked');
                    switchTheme('light');
                });
            }
            if (darkThemeBtn) {
                darkThemeBtn.addEventListener('click', () => {
                    console.log('Dark Theme button clicked');
                    switchTheme('dark');
                });
            }

            // Добавляем логи для отладки переноса слов в заголовках таблицы
            function logTableHeaderStyles() {
                const thElements = document.querySelectorAll('th');
                console.log('Стили заголовков таблицы для переноса слов:');
                thElements.forEach((th, index) => {
                    const computedStyle = getComputedStyle(th);
                    console.log(`TH ${index} (${th.textContent.trim()}):`);
                    console.log(`  white-space: ${computedStyle.whiteSpace}`);
                    console.log(`  word-break: ${computedStyle.wordBreak}`);
                    console.log(`  hyphens: ${computedStyle.hyphens}`);
                    console.log(`  width: ${computedStyle.width}`);
                    console.log(`  min-width: ${computedStyle.minWidth}`);
                    console.log(`  padding: ${computedStyle.padding}`);
                    console.log(`  text-align: ${computedStyle.textAlign}`);
                    console.log(`  line-height: ${computedStyle.lineHeight}`);
                    console.log(`  overflow: ${computedStyle.overflow}`);
                    console.log(`  text-overflow: ${computedStyle.textOverflow}`);
                    console.log(`  font-size: ${computedStyle.fontSize}`);
                });
            }

            // Логируем стили после инициализации
            setTimeout(logTableHeaderStyles, 1500);

            // Добавляем логи для проверки примененных стилей к th
            setTimeout(() => {
                console.log('Проверка примененных стилей к th элементам после обновлений:');
                const thElements = document.querySelectorAll('th');
                thElements.forEach((th, index) => {
                    const computedStyle = getComputedStyle(th);
                    console.log(`TH ${index} (${th.textContent.trim()}):`);
                    console.log(`  white-space: ${computedStyle.whiteSpace}`);
                    console.log(`  word-break: ${computedStyle.wordBreak}`);
                    console.log(`  font-size: ${computedStyle.fontSize}`);
                    console.log(`  padding: ${computedStyle.padding}`);
                    console.log(`  min-width: ${computedStyle.minWidth}`);
                    console.log(`  line-height: ${computedStyle.lineHeight}`);
                    console.log(`  overflow: ${computedStyle.overflow}`);
                    console.log(`  text-overflow: ${computedStyle.textOverflow}`);
                });
                console.log('Стили успешно применены: white-space: normal; word-break: keep-all; overflow: visible; для всех th.');
            }, 2000);

            // Добавляем логи для проверки примененных стилей к th
            setTimeout(() => {
                console.log('Applied styles to th: white-space: nowrap; word-break: keep-all;');
                const thElements = document.querySelectorAll('th');
                thElements.forEach((th, index) => {
                    const computedStyle = getComputedStyle(th);
                    console.log(`TH ${index} (${th.textContent}): white-space: ${computedStyle.whiteSpace}, word-break: ${computedStyle.wordBreak}`);
                });
            }, 1600);

            // Дополнительные логи для проверки изменений в стилях th
            setTimeout(() => {
                console.log('CSS changes applied to th elements: word-break: break-word; white-space: normal; font-size: 0.75rem; padding: 12px 10px; min-width: 100px;');
                const thElements = document.querySelectorAll('th');
                thElements.forEach((th, index) => {
                    const computedStyle = getComputedStyle(th);
                    console.log(`TH ${index} (${th.textContent}): font-size: ${computedStyle.fontSize}, word-break: ${computedStyle.wordBreak}, padding: ${computedStyle.padding}, white-space: ${computedStyle.whiteSpace}, min-width: ${computedStyle.minWidth}`);
                });
            }, 1600);

            // Add logging for balance alignment and styles
            function logBalanceAlignment() {
                const balanceItems = document.querySelectorAll('.balance-item');
                console.log('Balance alignment check:');
                balanceItems.forEach((item, index) => {
                    console.log(`Balance item ${index} (${item.querySelector('.balance-label').textContent}): width=${item.offsetWidth}, height=${item.offsetHeight}`);
                    const label = item.querySelector('.balance-label');
                    const value = item.querySelector('.balance-value');
                    console.log(`  Label: width=${label.offsetWidth}, height=${label.offsetHeight}`);
                    console.log(`  Value: width=${value.offsetWidth}, height=${value.offsetHeight}`);
                });
            }

            // Add logging for Starting Balance styles
            function logStartingBalanceStyles() {
                const startingBalance = document.getElementById('startingBalanceValue');
                if (startingBalance) {
                    const computedStyle = getComputedStyle(startingBalance);
                    console.log('Starting Balance computed styles:');
                    console.log('  background-color:', computedStyle.backgroundColor);
                    console.log('  color:', computedStyle.color);
                    console.log('  border:', computedStyle.border);
                    console.log('  border-radius:', computedStyle.borderRadius);
                    console.log('  padding:', computedStyle.padding);
                    console.log('  cursor:', computedStyle.cursor);
                    console.log('  box-shadow:', computedStyle.boxShadow);
                    console.log('  opacity:', computedStyle.opacity);
                    console.log('  transform:', computedStyle.transform);
                    console.log('  transition:', computedStyle.transition);
                    console.log('  classList:', startingBalance.classList.toString());
                    console.log('  Current theme:', document.documentElement.getAttribute('data-theme'));
                    console.log('  CSS variables:');
                    console.log('    --button-color:', getComputedStyle(document.documentElement).getPropertyValue('--button-color'));
                    console.log('    --button-text-color:', getComputedStyle(document.documentElement).getPropertyValue('--button-text-color'));
                    console.log('    --bg-color:', getComputedStyle(document.documentElement).getPropertyValue('--bg-color'));
                    console.log('    --text-color:', getComputedStyle(document.documentElement).getPropertyValue('--text-color'));
                } else {
                    console.log('Starting Balance element not found');
                }
            }

            // Add logging for Comment styles
            function logCommentStyles() {
                const monthCommentsTextarea = document.getElementById('monthCommentsInput');
                const commentsCells = document.querySelectorAll('.comments-cell');
                const currentTheme = document.documentElement.getAttribute('data-theme');
                console.log('Logging comment styles for theme:', currentTheme);
                console.log('  CSS variables:');
                console.log('    --text-color:', getComputedStyle(document.documentElement).getPropertyValue('--text-color'));
                console.log('    --bg-color:', getComputedStyle(document.documentElement).getPropertyValue('--bg-color'));
                if (monthCommentsTextarea) {
                    const computedStyle = getComputedStyle(monthCommentsTextarea);
                    console.log('Month Comments textarea styles:');
                    console.log('  color:', computedStyle.color);
                    console.log('  background-color:', computedStyle.backgroundColor);
                    console.log('  Applied styles confirmed: color set to var(--text-color) for visibility in dark theme.');
                } else {
                    console.log('Month Comments textarea not found');
                }
                commentsCells.forEach((cell, index) => {
                    const computedStyle = getComputedStyle(cell);
                    console.log(`Comments cell ${index} styles:`);
                    console.log('  color:', computedStyle.color);
                });
                console.log('Comment visibility updated for dark theme.');
            }

            // Log after init
            setTimeout(logBalanceAlignment, 1000);

            // Add theme toggle for testing
            document.addEventListener('keydown', function(e) {
                if (e.key === 't' || e.key === 'T') {
                    const currentTheme = document.documentElement.getAttribute('data-theme');
                    if (currentTheme === 'dark') {
                        document.documentElement.removeAttribute('data-theme');
                        console.log('Switched to light theme');
                    } else {
                        document.documentElement.setAttribute('data-theme', 'dark');
                        console.log('Switched to dark theme');
                    }
                    setTimeout(logBalanceAlignment, 500);
                    setTimeout(logStartingBalanceStyles, 500);
                }
            });
        });
    </script>
</body>
</html>
